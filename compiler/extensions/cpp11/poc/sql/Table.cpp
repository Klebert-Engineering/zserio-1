/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#include <zserio/CppRuntimeException.h>
#include <zserio/SqliteException.h>
#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>

#include "Table.h"

#include <iostream>

Table::Table(zserio::SqliteConnection& db, const std::string& tableName,
        const std::string& attachedDbName) :
        m_db(db), m_name(tableName), m_attachedDbName(attachedDbName)
{
}

Table::~Table()
{
}

void Table::createTable()
{
    std::string sqlQuery;
    appendCreateTableToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery.c_str());
}

void Table::deleteTable()
{
    std::string sqlQuery = "DROP TABLE ";
    appendTableNameToQuery(sqlQuery);
    m_db.executeUpdate(sqlQuery.c_str());
}

void Table::write(std::vector<Row>& rows)
{
    // assemble sql query
    std::string sqlQuery("INSERT INTO ");
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            "("
            "pk, "
            "data"
            ") VALUES (?, ?);";

    // write rows
    const bool wasTransactionStarted = m_db.startTransaction();
    sqlite3_stmt* statement = m_db.prepareStatement(sqlQuery);
    int result = SQLITE_OK;
    for (std::vector<Row>::iterator it = rows.begin(); it != rows.end(); ++it)
    {
        writeRow(*it, *statement);
        result = sqlite3_step(statement);
        if (result != SQLITE_DONE)
            break;

        sqlite3_clear_bindings(statement);
        result = sqlite3_reset(statement);
        if (result != SQLITE_OK)
            break;
    }
    sqlite3_finalize(statement);
    if (result != SQLITE_DONE && result != SQLITE_OK)
        throw zserio::SqliteException("Write: sqlite3_step() failed", result);

    m_db.endTransaction(wasTransactionStarted);
}

void Table::write(std::initializer_list<Row> _rows)
{
    std::vector<Row> rows(_rows);
    write(rows);
}

void Table::update(Row& row, const std::string& whereCondition)
{
    // assemble sql query
    std::string sqlQuery("UPDATE ");
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            " SET"
            " pk=?,"
            " data=?"
            " WHERE ";
    sqlQuery += whereCondition;

    // update row
    sqlite3_stmt* statement = m_db.prepareStatement(sqlQuery);
    writeRow(row, *statement);
    const int result = sqlite3_step(statement);
    sqlite3_finalize(statement);
    if (result != SQLITE_DONE)
        throw zserio::SqliteException("Update: sqlite3_step() failed", result);
}

void Table::readRow(sqlite3_stmt& statement,
        std::vector<Row>& rows)
{
    rows.resize(rows.size() + 1);
    Row& row = rows.back();

    // field pk
    if (sqlite3_column_type(&statement, 0) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(&statement, 0);
        row.setPk(static_cast<uint32_t>(intValue));
    }

    // field data
    if (sqlite3_column_type(&statement, 1) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(&statement, 1);
        const int blobDataLength = sqlite3_column_bytes(&statement, 1);
        zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        const Data blob(reader);
        row.setData(blob);
    }
}

void Table::writeRow(Row& row, sqlite3_stmt& statement)
{
    int result;
    // field pk
    if (!row.getPk())
    {
        result = sqlite3_bind_null(&statement, 1);
    }
    else
    {
        const int64_t intValue = static_cast<int64_t>(*row.getPk());
        result = sqlite3_bind_int64(&statement, 1, intValue);
    }
    if (result != SQLITE_OK)
        throw zserio::SqliteException("WriteRow: sqlite3_bind() for field pk failed", result);

    // field data
    if (!row.getData())
    {
        result = sqlite3_bind_null(&statement, 2);
    }
    else
    {
        Data& blob = *row.getData();
        zserio::BitStreamWriter writer;
        blob.write(writer);
        size_t blobDataLength;
        const uint8_t* blobData = writer.getWriteBuffer(blobDataLength);
        result = sqlite3_bind_blob(&statement, 2, blobData, static_cast<int>(blobDataLength), SQLITE_TRANSIENT);
    }
    if (result != SQLITE_OK)
        throw zserio::SqliteException("WriteRow: sqlite3_bind() for field data failed", result);
}

void Table::appendCreateTableToQuery(std::string& sqlQuery)
{
    sqlQuery += "CREATE TABLE ";
    appendTableNameToQuery(sqlQuery);
    sqlQuery +=
            "("
            "pk INTEGER PRIMARY KEY NOT NULL, "
            "data BLOB"
            ")";
}

void Table::appendTableNameToQuery(std::string& sqlQuery) const
{
    sqlQuery.append(m_attachedDbName.empty() ? m_name : (m_attachedDbName + "." + m_name));
}

Table::Row::Row()
{
}

Table::Row::~Row()
{
}

zserio::OptionalHolder<uint32_t>& Table::Row::getPk() noexcept
{
    return m_pk_;
}

const zserio::OptionalHolder<uint32_t>& Table::Row::getPk() const noexcept
{
    return m_pk_;
}

void Table::Row::setPk(const zserio::OptionalHolder<uint32_t>& _pk)
{
    m_pk_ = _pk;
}

zserio::OptionalHolder<Data>& Table::Row::getData()
{
    return m_data_;
}

const zserio::OptionalHolder<Data>& Table::Row::getData() const
{
    return m_data_;
}

void Table::Row::setData(const zserio::OptionalHolder<Data>& _data)
{
    m_data_ = _data;
}

void Table::Row::setData(zserio::OptionalHolder<Data>&& _data)
{
    m_data_ = std::move(_data);
}

Table::Reader Table::createReader(const std::string& condition) const
{
    // assemble sql query
    std::string sqlQuery;
    sqlQuery +=
            "SELECT "
            "pk, "
            "data"
            " FROM ";
    appendTableNameToQuery(sqlQuery);
    if (!condition.empty())
    {
        sqlQuery += " WHERE ";
        sqlQuery += condition;
    }

    return Reader(m_db, sqlQuery);
}

Table::Reader::Reader(zserio::SqliteConnection& db, const std::string& sqlQuery)
{
    m_stmt.reset(db.prepareStatement(sqlQuery));
    makeStep();
}

bool Table::Reader::hasNext() const noexcept
{
    return m_lastResult == SQLITE_ROW;
}

Table::Row Table::Reader::next()
{
    if (!hasNext())
        throw zserio::SqliteException("Table::Reader::next: next row is not available", m_lastResult);

    Row row;
    // field pk
    if (sqlite3_column_type(m_stmt.get(), 0) != SQLITE_NULL)
    {
        const int64_t intValue = sqlite3_column_int64(m_stmt.get(), 0);
        row.setPk(intValue);
    }

    // field data
    if (sqlite3_column_type(m_stmt.get(), 1) != SQLITE_NULL)
    {
        const void* blobData = sqlite3_column_blob(m_stmt.get(), 1);
        const int blobDataLength = sqlite3_column_bytes(m_stmt.get(), 1);
        zserio::BitStreamReader reader(reinterpret_cast<const uint8_t*>(blobData),
                static_cast<size_t>(blobDataLength));
        const Data blob(reader);
        row.setData(blob);
    }

    makeStep();

    return row;
}

void Table::Reader::makeStep()
{
    m_lastResult = sqlite3_step(m_stmt.get());
    if (m_lastResult != SQLITE_ROW && m_lastResult != SQLITE_DONE)
        throw zserio::SqliteException("Read: sqlite3_step() failed", m_lastResult);
}
