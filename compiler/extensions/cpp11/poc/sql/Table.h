/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#ifndef TABLE_H
#define TABLE_H

#include <memory>
#include <vector>
#include <string>
#include <sqlite3.h>
#include <zserio/Types.h>
#include <zserio/SqliteConnection.h>
#include <zserio/OptionalHolder.h>

#include "Data.h"

#include <iostream>
// TODO: This should be part of zserio runtime.
namespace zserio
{

struct SqliteFinalizer
{
    void operator()(sqlite3_stmt* ptr) const
    {
        sqlite3_finalize(ptr);
    }
};

} // namespace zserio


class Table
{
public:
    class Row
    {
    public:
        Row();
        ~Row();

        // Row(const Row& other) { std::cout << "copy row" << std::endl; *this = other; }
        // Row& operator=(const Row& other) { std::cout << "copy assign row" << std::endl; m_pk_ = other.m_pk_; m_data_ = other.m_data_; }

        // Row(Row&& other) { std::cout << "move row" << std::endl; *this = std::move(other); }
        // Row& operator=(Row&& other) { std::cout << "move assign row" << std::endl; m_pk_ = std::move(other.m_pk_); m_data_ = std::move(other.m_data_); }

        // new in cpp11
        // TODO: should be explicit? std::initializer_list<Row> is quite convenient (see test.cpp)
        template<typename ZSERIO_T_data>
        Row(const zserio::OptionalHolder<uint32_t>& _pk, ZSERIO_T_data&& _data)
        :   m_pk_(_pk), m_data_(std::forward<ZSERIO_T_data>(_data))
        {}

        zserio::OptionalHolder<uint32_t>& getPk() noexcept; // non-const getter has sense also for simple types?
        const zserio::OptionalHolder<uint32_t>& getPk() const noexcept;
        void setPk(const zserio::OptionalHolder<uint32_t>& _pk); // simple type

        zserio::OptionalHolder<Data>& getData();
        const zserio::OptionalHolder<Data>& getData() const;
        void setData(const zserio::OptionalHolder<Data>& _data);
        void setData(zserio::OptionalHolder<Data>&& _data); // not a simple type

    private:
        zserio::OptionalHolder<uint32_t> m_pk_;
        zserio::OptionalHolder<Data> m_data_;
    };

    Table(zserio::SqliteConnection& db, const std::string& tableName, const std::string& attachedDbName = "");
    ~Table();

    void createTable();
    void deleteTable();

    void write(std::vector<Row>& rows);
    void write(std::initializer_list<Row> rows); // new in cpp11
    void update(Row& row, const std::string& whereCondition);

    class Reader final
    {
    public:
        Reader(const Reader& other) = delete;
        Reader& operator=(const Reader& other) = delete;

        Reader(Reader&& other) = default;
        Reader& operator=(Reader&& other) = default;

        bool hasNext() const noexcept;
        Row next();

    private:
        explicit Reader(zserio::SqliteConnection& db, const std::string& sqlQuery);
        friend class Table;

        void makeStep();

        std::unique_ptr<sqlite3_stmt, zserio::SqliteFinalizer> m_stmt;
        int m_lastResult;
    };

    Reader createReader(const std::string& condition = "") const;

private:
    static void readRow(sqlite3_stmt& statement,
            std::vector<Table::Row>& rows);
    static void writeRow(Table::Row& row, sqlite3_stmt& statement);

    void appendCreateTableToQuery(std::string& sqlQuery);

    void appendTableNameToQuery(std::string& sqlQuery) const;

    zserio::SqliteConnection& m_db;
    const std::string m_name;
    const std::string m_attachedDbName;
};


#endif // TABLE_H


