/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "Structure.h"

Structure::Structure() :
        m_areChildrenInitialized(false)
{}

Structure::Structure(zserio::BitStreamReader& in) :
        m_areChildrenInitialized(true)
{
    read(in);
}

Structure::Structure(const Structure& other) :
        m_size(other.m_size),
        m_array(other.m_array),
        m_hasExtra(other.m_hasExtra),
        m_extraSize(other.m_extraSize),
        m_extraArray(other.m_extraArray),
        m_str(other.m_str)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

Structure& Structure::operator=(const Structure& other)
{
    m_size = other.m_size;
    m_array = other.m_array;
    m_hasExtra = other.m_hasExtra;
    m_extraSize = other.m_extraSize;
    m_extraArray = other.m_extraArray;
    m_str = other.m_str;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

void Structure::initializeChildren()
{
    m_array.initialize(getSize());
    if (getHasExtra())
        m_extraArray.get().initialize(getExtraSize().get());

    m_areChildrenInitialized = true;
}

uint32_t Structure::getSize() const
{
    return m_size;
}

void Structure::setSize(uint32_t _size)
{
    m_size = _size;
}

Array& Structure::getArray()
{
    return m_array;
}

const Array& Structure::getArray() const
{
    return m_array;
}

void Structure::setArray(const Array& _array)
{
    m_array = _array;
}

void Structure::setArray(Array&& _array)
{
    m_array = std::move(_array);
}

bool Structure::getHasExtra() const
{
    return m_hasExtra;
}

void Structure::setHasExtra(bool _hasExtra)
{
    m_hasExtra = _hasExtra;
}

zserio::OptionalHolder<uint32_t>& Structure::getExtraSize()
{
    return m_extraSize;
}

const zserio::OptionalHolder<uint32_t>& Structure::getExtraSize() const
{
    return m_extraSize;
}

void Structure::setExtraSize(const zserio::OptionalHolder<uint32_t>& _extraSize)
{
    m_extraSize = _extraSize;
}

bool Structure::hasExtraSize() const
{
    return (getHasExtra());
}

zserio::OptionalHolder<Array>& Structure::getExtraArray()
{
    return m_extraArray;
}

const zserio::OptionalHolder<Array>& Structure::getExtraArray() const
{
    return m_extraArray;
}

void Structure::setExtraArray(const zserio::OptionalHolder<Array>& _extraArray)
{
    m_extraArray = _extraArray;
}

void Structure::setExtraArray(zserio::OptionalHolder<Array>&& _extraArray)
{
    m_extraArray = std::move(_extraArray);
}

bool Structure::hasExtraArray() const
{
    return (getHasExtra());
}

String& Structure::getStr()
{
    return m_str;
}

const String& Structure::getStr() const
{
    return m_str;
}

void Structure::setStr(const String& _str)
{
    m_str = _str;
}

void Structure::setStr(String&& _str)
{
    m_str = std::move(_str);
}

zserio::OptionalHolder<Structure>& Structure::getRecursive()
{
    return m_recursive;
}

const zserio::OptionalHolder<Structure>& Structure::getRecursive() const
{
    return m_recursive;
}

void Structure::setRecursive(const zserio::OptionalHolder<Structure>& _recursive)
{
    m_recursive = _recursive;
}

void Structure::setRecursive(zserio::OptionalHolder<Structure>&& _recursive)
{
    m_recursive = std::move(_recursive);
}

bool Structure::hasRecursive() const
{
    return (getHasExtra());
}

size_t Structure::bitSizeOf(size_t _bitPosition) const
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += UINT8_C(32);
    _endBitPosition += m_array.bitSizeOf(_endBitPosition);
    _endBitPosition += UINT8_C(1);
    if (getHasExtra())
    {
        _endBitPosition += UINT8_C(32);
    }
    if (getHasExtra())
    {
        _endBitPosition += m_extraArray.get().bitSizeOf(_endBitPosition);
    }
    _endBitPosition += m_str.bitSizeOf(_endBitPosition);

    return _endBitPosition - _bitPosition;
}

size_t Structure::initializeOffsets(size_t _bitPosition)
{
    size_t _endBitPosition = _bitPosition;

    _endBitPosition += UINT8_C(32);
    _endBitPosition = m_array.initializeOffsets(_endBitPosition);
    _endBitPosition += UINT8_C(1);
    if (getHasExtra())
    {
        _endBitPosition += UINT8_C(32);
    }
    if (getHasExtra())
    {
        _endBitPosition = m_extraArray.get().initializeOffsets(_endBitPosition);
    }
    _endBitPosition = m_str.initializeOffsets(_endBitPosition);

    return _endBitPosition;
}

bool Structure::operator==(const Structure& other) const
{
    if (this != &other)
    {
        return
                (m_size == other.m_size) &&
                (m_array == other.m_array) &&
                (m_hasExtra == other.m_hasExtra) &&
                (!(getHasExtra()) || m_extraSize == other.m_extraSize) &&
                (!(getHasExtra()) || m_extraArray == other.m_extraArray) &&
                (m_str == other.m_str);
    }

    return true;
}

int Structure::hashCode() const
{
    int _result = zserio::HASH_SEED;

    _result = zserio::calcHashCode(_result, m_size);
    _result = zserio::calcHashCode(_result, m_array);
    _result = zserio::calcHashCode(_result, m_hasExtra);
    if (getHasExtra())
        _result = zserio::calcHashCode(_result, m_extraSize);
    if (getHasExtra())
        _result = zserio::calcHashCode(_result, m_extraArray);
    _result = zserio::calcHashCode(_result, m_str);

    return _result;
}

void Structure::read(zserio::BitStreamReader& in)
{
    m_size = (uint32_t)in.readBits(UINT8_C(32));
    m_array.initialize(getSize());
    m_array.read(in);
    m_hasExtra = (bool)in.readBool();
    if (getHasExtra()) // TODO: hasExtraSize?
    {
        m_extraSize = in.readBits(UINT8_C(32));
    }
    if (getHasExtra()) // TODO: hasExtraArray?
    {
        m_extraArray = Array(in, getExtraSize().get()); // TODO: do we need emplace?
    }
    m_str.read(in);
    if (getHasExtra()) // TODO: hasRecursive?
    {
        m_recursive = Structure(in);
    }
}

void Structure::write(zserio::BitStreamWriter& out, zserio::PreWriteAction preWriteAction)
{
    if ((preWriteAction & zserio::PRE_WRITE_INITIALIZE_CHILDREN) != 0)
        initializeChildren();

    out.writeBits(m_size, UINT8_C(32));
    m_array.write(out, zserio::NO_PRE_WRITE_ACTION);
    out.writeBool(m_hasExtra);
    if (getHasExtra()) // TODO: hasExtraSize?
    {
        out.writeBits(m_extraSize.get(), UINT8_C(32));
    }
    if (getHasExtra()) // TODO: hasExtraArray?
    {
        m_extraArray.get().write(out, zserio::NO_PRE_WRITE_ACTION);
    }
    m_str.write(out, zserio::NO_PRE_WRITE_ACTION);
    if (getHasExtra()) // TODO: hasRecursive?
    {
        m_recursive.get().write(out, zserio::NO_PRE_WRITE_ACTION);
    }
}

