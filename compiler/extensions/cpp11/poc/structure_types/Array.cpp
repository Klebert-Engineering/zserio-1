/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "Array.h"

Array::Array() :
        m_isInitialized(false)
{
}

Array::Array(zserio::BitStreamReader& in,
        uint32_t _size) :
        m_size(_size),
        m_isInitialized(true)
{
    read(in);
}

Array::Array(const Array& other) :
        m_values(other.m_values)
{
    if (other.m_isInitialized)
        initialize(other.m_size);
    else
        m_isInitialized = false;
}

Array& Array::operator=(const Array& other)
{
    m_values = other.m_values;
    if (other.m_isInitialized)
        initialize(other.m_size);
    else
        m_isInitialized = false;

    return *this;
}

Array::Array(uint32_t _size, const std::vector<int32_t>& _values)
:   m_size(_size), m_values(_values)
{}

Array::Array(uint32_t _size, std::vector<int32_t>&& _values)
:   m_size(_size), m_values(std::move(_values))
{}

void Array::initialize(
        uint32_t _size)
{
    m_size = _size;
    m_isInitialized = true;
}

uint32_t Array::getSize() const
{
    if (!m_isInitialized)
        throw zserio::CppRuntimeException("Parameter size of compound Array "
                "is not initialized!");

    return m_size;
}

std::vector<int32_t>& Array::getValues()
{
    return m_values;
}

const std::vector<int32_t>& Array::getValues() const
{
    return m_values;
}

void Array::setValues(const std::vector<int32_t>& _values)
{
    m_values = _values;
}

void Array::setValues(std::vector<int32_t>&& _values)
{
    m_values = std::move(_values);
}

size_t Array::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    //endBitPosition += m_values.bitSizeOf(endBitPosition, UINT8_C(32));

    return endBitPosition - bitPosition;
}

size_t Array::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    //endBitPosition = m_values.initializeOffsets(endBitPosition, UINT8_C(32));

    return endBitPosition;
}

bool Array::operator==(const Array& other) const
{
    if (this != &other)
    {
        return
                (getSize() == other.getSize()) &&
                (m_values == other.m_values);
    }

    return true;
}

int Array::hashCode() const
{
    int result = zserio::HASH_SEED;

    result = zserio::calcHashCode(result, getSize());
    //result = zserio::calcHashCode(result, m_values);

    return result;
}

void Array::read(zserio::BitStreamReader& in)
{
    //m_values.read(in, static_cast<size_t>(getSize()), UINT8_C(32));
}

void Array::write(zserio::BitStreamWriter& out, zserio::PreWriteAction)
{
    /*if (m_values.size() != static_cast<size_t>(getSize()))
    {
        throw zserio::CppRuntimeException("Write: Wrong array length for field Array.values: " +
                zserio::convertToString(m_values.size()) + " != " +
                zserio::convertToString(static_cast<size_t>(getSize())) + "!");
    }
    m_values.write(out, UINT8_C(32));*/
}

