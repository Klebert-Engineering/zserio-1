#ifndef ZSERIO_CPP_RUNTIME_EXCEPTION_H_INC
#define ZSERIO_CPP_RUNTIME_EXCEPTION_H_INC

#include <type_traits>
#include <exception>

#include "zserio/StringConvertUtil.h"
#include "zserio/StringView.h"
#include "zserio/Enums.h"
#include "zserio/Traits.h"

namespace zserio
{

/**
 * Exception throw when an error within the Zserio C++ runtime library occurs.
 */
class CppRuntimeException : public std::exception
{
public:
    /**
     * Constructor.
     *
     * \param message Description of the error.
     */
    explicit CppRuntimeException(const char* message = "");

    /**
     * Constructor.
     *
     * \param message Description of the error.
     */
    explicit CppRuntimeException(StringView message);

    /**
     * Method generated by default.
     * \{
     */
    ~CppRuntimeException() = default;

    CppRuntimeException(const CppRuntimeException& other) = default;
    CppRuntimeException& operator=(const CppRuntimeException& other) = default;

    CppRuntimeException(CppRuntimeException&& other) = default;
    CppRuntimeException& operator=(CppRuntimeException&& other) = default;
    /**
     * \}
     */

    /**
     * Appends any value for which append method is implemented to the description.
     *
     * \param value Value to append.
     */
    template <typename T>
    CppRuntimeException& operator+(const T& value)
    {
        return append(value);
    }

    const char* what() const noexcept override;

protected:
    /**
     * Appends a message to the description.
     *
     * \param message Description of the error to append.
     */
    CppRuntimeException& append(const char* message);

    /**
     * Appends a message to the description.
     *
     * \param message Description of the error to append.
     */
    CppRuntimeException& append(StringView message);

    /**
     * Appends a bool value to the description.
     *
     * \param value Bool value to append.
     */
    CppRuntimeException& append(bool value);

    /**
     * Appends a float value to the description.
     *
     * \param value Float value to append.
     */
    CppRuntimeException& append(float value);

    /**
     * Appends a double value to the description.
     *
     * \param value Double value to append.
     */
    CppRuntimeException& append(double value);

    /**
     * Appends any integral value to the description.
     *
     * \param value Integral value to append.
     */
    template <typename T, typename std::enable_if<std::is_integral<T>::value, int>::type = 0>
    CppRuntimeException& append(T value)
    {
        char buffer[24];
        const char* stringValue = convertIntToString(buffer, value);
        return append(stringValue);
    }

    /**
     * Appends any enumeration value to the description.
     *
     * \param value Enumeration value to append.
     */
    template <typename T, typename std::enable_if<std::is_enum<T>::value, int>::type = 0>
    CppRuntimeException& append(T value)
    {
        const char* stringValue = enumToString(value);
        return append(stringValue);
    }

    /**
     * Appends any object which implement getValue() method (e.g. bitmask).
     *
     * \param value Object with getValue() method to append.
     */
    template <typename T, typename std::enable_if<has_get_value<T>::value, int>::type = 0>
    CppRuntimeException& append(T value)
    {
        return append(value.getValue());
    }

private:
    // Note: If you move this to public section, old MSVC 2015 compiler will fail with internal compiler error!
    static constexpr size_t BUFFER_SIZE = 512;

    void appendImpl(const char* message, size_t size);

    char m_buffer[BUFFER_SIZE]; // note that fixed sized array is deeply copied on copy operations and its OK
    size_t m_len = 0;
};

namespace detail
{

/** Helper middle class for descendants which defines correct operator+ overloads. */
template <typename EXCEPTION>
class CppRuntimeExceptionHelper : public CppRuntimeException
{
public:
    using CppRuntimeException::CppRuntimeException;

    template <typename T>
    EXCEPTION& operator+(const T& value)
    {
        return static_cast<EXCEPTION&>(append(value));
    }

protected:
    using BaseType = CppRuntimeExceptionHelper<EXCEPTION>;
};

} // namespace detail

} // namespace zserio

#endif // ifndef ZSERIO_CPP_RUNTIME_EXCEPTION_H_INC
