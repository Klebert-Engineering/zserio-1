/**
 * Automatically generated by Zserio C++ extension version 2.9.0-pre1.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, typeInfoCode, reflectionCode, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/TypeInfo.h>
#include <zserio/AnyHolder.h>
#include <zserio/Reflectable.h>
#include <functional>

#include <test_object/DummyObject.h>

namespace test_object
{

DummyObject::ZserioElementFactory_nestedArray::ZserioElementFactory_nestedArray(DummyObject& owner) :
        m_ownerRef(owner)
{}

void DummyObject::ZserioElementFactory_nestedArray::create(::zserio::vector<::test_object::DummyNested>& array,
        ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(in, static_cast<uint32_t>(m_ownerRef.get().getValue()), array.get_allocator());
}

void DummyObject::ZserioElementFactory_nestedArray::create(::zserio::PackingContextNode& contextNode,
        ::zserio::vector<::test_object::DummyNested>& array, ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(contextNode, in, static_cast<uint32_t>(m_ownerRef.get().getValue()), array.get_allocator());
}

DummyObject::ZserioElementInitializer_nestedArray::ZserioElementInitializer_nestedArray(DummyObject& owner) :
        m_ownerRef(owner)
{}

void DummyObject::ZserioElementInitializer_nestedArray::initialize(::test_object::DummyNested& element, size_t index) const
{
    (void)index;
    element.initialize(static_cast<uint32_t>(m_ownerRef.get().getValue()));
}

DummyObject::DummyObject(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_value_(uint32_t()),
        m_nested_(allocator),
        m_text_(allocator),
        m_nestedArray_(::zserio::ObjectArrayTraits<::test_object::DummyNested, ZserioElementFactory_nestedArray>(), allocator),
        m_textArray_(::zserio::StringArrayTraits(), allocator),
        m_externArray_(::zserio::NullOpt),
        m_bytesArray_(::zserio::NullOpt),
        m_optionalBool_(::zserio::NullOpt),
        m_optionalNested_(::zserio::NullOpt)
{
}

DummyObject::DummyObject(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_value_(readValue(in)),
        m_nested_(readNested(in, allocator)),
        m_text_(readText(in, allocator)),
        m_nestedArray_(readNestedArray(in, allocator)),
        m_textArray_(readTextArray(in, allocator)),
        m_externArray_(readExternArray(in, allocator)),
        m_bytesArray_(readBytesArray(in, allocator)),
        m_optionalBool_(readOptionalBool(in)),
        m_optionalNested_(readOptionalNested(in, allocator))
{
}

DummyObject::DummyObject(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_value_(readValue(contextNode, in)),
        m_nested_(readNested(contextNode, in, allocator)),
        m_text_(readText(in, allocator)),
        m_nestedArray_(readNestedArray(contextNode, in, allocator)),
        m_textArray_(readTextArray(in, allocator)),
        m_externArray_(readExternArray(in, allocator)),
        m_bytesArray_(readBytesArray(in, allocator)),
        m_optionalBool_(readOptionalBool(in)),
        m_optionalNested_(readOptionalNested(contextNode, in, allocator))
{
}

DummyObject::DummyObject(const DummyObject& other) :
        m_value_(other.m_value_),
        m_nested_(other.m_nested_),
        m_text_(other.m_text_),
        m_nestedArray_(other.m_nestedArray_),
        m_textArray_(other.m_textArray_),
        m_externArray_(other.m_externArray_),
        m_bytesArray_(other.m_bytesArray_),
        m_optionalBool_(other.m_optionalBool_),
        m_optionalNested_(other.m_optionalNested_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

DummyObject& DummyObject::operator=(const DummyObject& other)
{
    m_value_ = other.m_value_;
    m_nested_ = other.m_nested_;
    m_text_ = other.m_text_;
    m_nestedArray_ = other.m_nestedArray_;
    m_textArray_ = other.m_textArray_;
    m_externArray_ = other.m_externArray_;
    m_bytesArray_ = other.m_bytesArray_;
    m_optionalBool_ = other.m_optionalBool_;
    m_optionalNested_ = other.m_optionalNested_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

DummyObject::DummyObject(DummyObject&& other) :
        m_value_(::std::move(other.m_value_)),
        m_nested_(::std::move(other.m_nested_)),
        m_text_(::std::move(other.m_text_)),
        m_nestedArray_(::std::move(other.m_nestedArray_)),
        m_textArray_(::std::move(other.m_textArray_)),
        m_externArray_(::std::move(other.m_externArray_)),
        m_bytesArray_(::std::move(other.m_bytesArray_)),
        m_optionalBool_(::std::move(other.m_optionalBool_)),
        m_optionalNested_(::std::move(other.m_optionalNested_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

DummyObject& DummyObject::operator=(DummyObject&& other)
{
    m_value_ = ::std::move(other.m_value_);
    m_nested_ = ::std::move(other.m_nested_);
    m_text_ = ::std::move(other.m_text_);
    m_nestedArray_ = ::std::move(other.m_nestedArray_);
    m_textArray_ = ::std::move(other.m_textArray_);
    m_externArray_ = ::std::move(other.m_externArray_);
    m_bytesArray_ = ::std::move(other.m_bytesArray_);
    m_optionalBool_ = ::std::move(other.m_optionalBool_);
    m_optionalNested_ = ::std::move(other.m_optionalNested_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

DummyObject::DummyObject(::zserio::PropagateAllocatorT,
        const DummyObject& other, const allocator_type& allocator) :
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator)),
        m_nested_(::zserio::allocatorPropagatingCopy(other.m_nested_, allocator)),
        m_text_(::zserio::allocatorPropagatingCopy(other.m_text_, allocator)),
        m_nestedArray_(::zserio::allocatorPropagatingCopy(other.m_nestedArray_, allocator)),
        m_textArray_(::zserio::allocatorPropagatingCopy(other.m_textArray_, allocator)),
        m_externArray_(::zserio::allocatorPropagatingCopy(other.m_externArray_, allocator)),
        m_bytesArray_(::zserio::allocatorPropagatingCopy(other.m_bytesArray_, allocator)),
        m_optionalBool_(::zserio::allocatorPropagatingCopy(other.m_optionalBool_, allocator)),
        m_optionalNested_(::zserio::allocatorPropagatingCopy(other.m_optionalNested_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

const ::zserio::ITypeInfo& DummyObject::typeInfo()
{
    static const ::zserio::StringView templateName;
    static const ::zserio::Span<::zserio::BasicTemplateArgumentInfo<allocator_type>> templateArguments;

    static const ::std::array<::zserio::StringView, 1> nestedTypeArguments = {
        ::zserio::makeStringView("getValue()")
    };
    static const ::std::array<::zserio::StringView, 1> nestedArrayTypeArguments = {
        ::zserio::makeStringView("getValue()")
    };
    static const ::std::array<::zserio::StringView, 1> optionalNestedTypeArguments = {
        ::zserio::makeStringView("getValue()")
    };
    static const ::std::array<::zserio::BasicFieldInfo<allocator_type>, 9> fields = {
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("value"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getUInt32(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("nested"), // schemaName
            ::test_object::DummyNested::typeInfo(), // typeInfo
            nestedTypeArguments, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("text"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getString(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("nestedArray"), // schemaName
            ::test_object::DummyNested::typeInfo(), // typeInfo
            nestedArrayTypeArguments, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("textArray"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getString(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("externArray"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getBitBuffer(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("bytesArray"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getBytes(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("optionalBool"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getBool(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("optionalNested"), // schemaName
            ::test_object::DummyNested::typeInfo(), // typeInfo
            optionalNestedTypeArguments, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        }
    };

    static const ::zserio::Span<::zserio::BasicParameterInfo<allocator_type>> parameters;

    static const ::zserio::Span<::zserio::BasicFunctionInfo<allocator_type>> functions;

    static const ::zserio::StructTypeInfo<allocator_type> typeInfo = {
        ::zserio::makeStringView("test_object.DummyObject"),
        [](const allocator_type& allocator) -> ::zserio::IReflectablePtr
        {
            return std::allocate_shared<::zserio::ReflectableOwner<DummyObject>>(allocator, allocator);
        },
        templateName, templateArguments,
        fields, parameters, functions
    };

    return typeInfo;
}

::zserio::IReflectableConstPtr DummyObject::reflectable(const allocator_type& allocator) const
{
    class Reflectable : public ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>
    {
    public:
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getField;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getParameter;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::callFunction;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getAnyValue;

        explicit Reflectable(const ::test_object::DummyObject& object, const allocator_type& allocator) :
                ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>(::test_object::DummyObject::typeInfo(), allocator),
                m_object(object)
        {}

        virtual size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_object.bitSizeOf(bitPosition);
        }

        virtual void write(::zserio::BitStreamWriter& writer) const override
        {
            m_object.write(writer);
        }

        virtual ::zserio::IReflectableConstPtr getField(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                return ::zserio::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nested"))
            {
                return m_object.getNested().reflectable(get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                return ::zserio::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nestedArray"))
            {
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getNestedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("textArray"))
            {
                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getString(), m_object.getTextArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externArray"))
            {
                if (!m_object.isExternArraySet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getBitBuffer(), m_object.getExternArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesArray"))
            {
                if (!m_object.isBytesArraySet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getBytes(), m_object.getBytesArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalBool"))
            {
                if (!m_object.isOptionalBoolSet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getBool(m_object.getOptionalBool(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalNested"))
            {
                if (!m_object.isOptionalNestedSet())
                    return nullptr;

                return m_object.getOptionalNested().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'DummyObject'!";
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const allocator_type& allocator) const override
        {
            return ::zserio::AnyHolder<>(::std::cref(m_object), allocator);
        }

    private:
        const ::test_object::DummyObject& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, *this, allocator);
}

::zserio::IReflectablePtr DummyObject::reflectable(const allocator_type& allocator)
{
    class Reflectable : public ::zserio::ReflectableAllocatorHolderBase<allocator_type>
    {
    public:
        explicit Reflectable(::test_object::DummyObject& object, const allocator_type& allocator) :
                ::zserio::ReflectableAllocatorHolderBase<allocator_type>(::test_object::DummyObject::typeInfo(), allocator),
                m_object(object)
        {}

        virtual void initializeChildren() override
        {
            m_object.initializeChildren();
        }

        virtual size_t initializeOffsets(size_t bitPosition) override
        {
            return m_object.initializeOffsets(bitPosition);
        }

        virtual size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_object.bitSizeOf(bitPosition);
        }

        virtual void write(::zserio::BitStreamWriter& writer) const override
        {
            m_object.write(writer);
        }

        virtual ::zserio::IReflectableConstPtr getField(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                return ::zserio::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nested"))
            {
                return m_object.getNested().reflectable(get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                return ::zserio::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nestedArray"))
            {
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getNestedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("textArray"))
            {
                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getString(), m_object.getTextArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externArray"))
            {
                if (!m_object.isExternArraySet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getBitBuffer(), m_object.getExternArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesArray"))
            {
                if (!m_object.isBytesArraySet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getBytes(), m_object.getBytesArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalBool"))
            {
                if (!m_object.isOptionalBoolSet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getBool(m_object.getOptionalBool(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalNested"))
            {
                if (!m_object.isOptionalNestedSet())
                    return nullptr;

                return m_object.getOptionalNested().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'DummyObject'!";
        }

        virtual ::zserio::IReflectablePtr getField(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                return ::zserio::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nested"))
            {
                return m_object.getNested().reflectable(get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                return ::zserio::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nestedArray"))
            {
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getNestedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("textArray"))
            {
                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getString(), m_object.getTextArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externArray"))
            {
                if (!m_object.isExternArraySet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getBitBuffer(), m_object.getExternArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesArray"))
            {
                if (!m_object.isBytesArraySet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getBytes(), m_object.getBytesArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalBool"))
            {
                if (!m_object.isOptionalBoolSet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getBool(m_object.getOptionalBool(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalNested"))
            {
                if (!m_object.isOptionalNestedSet())
                    return nullptr;

                return m_object.getOptionalNested().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'DummyObject'!";
        }

        virtual void setField(::zserio::StringView name,
                const ::zserio::AnyHolder<allocator_type>& value) override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                m_object.setValue(value.get<uint32_t>());
                return;
            }
            if (name == ::zserio::makeStringView("nested"))
            {
                m_object.setNested(value.get<::test_object::DummyNested>());
                return;
            }
            if (name == ::zserio::makeStringView("text"))
            {
                m_object.setText(value.get<::zserio::string<>>());
                return;
            }
            if (name == ::zserio::makeStringView("nestedArray"))
            {
                m_object.setNestedArray(value.get<::zserio::vector<::test_object::DummyNested>>());
                return;
            }
            if (name == ::zserio::makeStringView("textArray"))
            {
                m_object.setTextArray(value.get<::zserio::vector<::zserio::string<>>>());
                return;
            }
            if (name == ::zserio::makeStringView("externArray"))
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.resetExternArray();
                    return;
                }

                m_object.setExternArray(value.get<::zserio::vector<::zserio::BitBuffer>>());
                return;
            }
            if (name == ::zserio::makeStringView("bytesArray"))
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.resetBytesArray();
                    return;
                }

                m_object.setBytesArray(value.get<::zserio::vector<::zserio::vector<uint8_t>>>());
                return;
            }
            if (name == ::zserio::makeStringView("optionalBool"))
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.resetOptionalBool();
                    return;
                }

                m_object.setOptionalBool(value.get<bool>());
                return;
            }
            if (name == ::zserio::makeStringView("optionalNested"))
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.resetOptionalNested();
                    return;
                }

                m_object.setOptionalNested(value.get<::test_object::DummyNested>());
                return;
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'DummyObject'!";
        }

        virtual ::zserio::IReflectablePtr createField(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                m_object.setValue(uint32_t());
                return ::zserio::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nested"))
            {
                m_object.setNested(::test_object::DummyNested(get_allocator()));
                return m_object.getNested().reflectable(get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                m_object.setText(::zserio::string<>(get_allocator()));
                return ::zserio::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("nestedArray"))
            {
                m_object.setNestedArray(::zserio::vector<::test_object::DummyNested>(get_allocator()));
                return ::zserio::ReflectableFactory::getCompoundArray(m_object.getNestedArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("textArray"))
            {
                m_object.setTextArray(::zserio::vector<::zserio::string<>>(get_allocator()));
                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getString(), m_object.getTextArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externArray"))
            {
                m_object.setExternArray(::zserio::vector<::zserio::BitBuffer>(get_allocator()));
                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getBitBuffer(), m_object.getExternArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesArray"))
            {
                m_object.setBytesArray(::zserio::vector<::zserio::vector<uint8_t>>(get_allocator()));
                return ::zserio::ReflectableFactory::getBuiltinArray(::zserio::BuiltinTypeInfo<allocator_type>::getBytes(), m_object.getBytesArray(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalBool"))
            {
                m_object.setOptionalBool(bool());
                return ::zserio::ReflectableFactory::getBool(m_object.getOptionalBool(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalNested"))
            {
                m_object.setOptionalNested(::test_object::DummyNested(get_allocator()));
                return m_object.getOptionalNested().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'DummyObject'!";
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const allocator_type& allocator) const override
        {
            return ::zserio::AnyHolder<>(::std::cref(m_object), allocator);
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const allocator_type& allocator) override
        {
            return ::zserio::AnyHolder<>(::std::ref(m_object), allocator);
        }

    private:
        ::test_object::DummyObject& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, *this, allocator);
}

void DummyObject::initializeChildren()
{
    m_nested_.initialize(static_cast<uint32_t>(getValue()));
    m_nestedArray_.initializeElements(ZserioElementInitializer_nestedArray(*this));
    if (isOptionalNestedSet())
        m_optionalNested_.value().initialize(static_cast<uint32_t>(getValue()));

    m_areChildrenInitialized = true;
}

uint32_t DummyObject::getValue() const
{
    return m_value_;
}

void DummyObject::setValue(uint32_t value_)
{
    m_value_ = value_;
}

::test_object::DummyNested& DummyObject::getNested()
{
    return m_nested_;
}

const ::test_object::DummyNested& DummyObject::getNested() const
{
    return m_nested_;
}

void DummyObject::setNested(const ::test_object::DummyNested& nested_)
{
    m_nested_ = nested_;
}

void DummyObject::setNested(::test_object::DummyNested&& nested_)
{
    m_nested_ = ::std::move(nested_);
}

::zserio::string<>& DummyObject::getText()
{
    return m_text_;
}

const ::zserio::string<>& DummyObject::getText() const
{
    return m_text_;
}

void DummyObject::setText(const ::zserio::string<>& text_)
{
    m_text_ = text_;
}

void DummyObject::setText(::zserio::string<>&& text_)
{
    m_text_ = ::std::move(text_);
}

::zserio::vector<::test_object::DummyNested>& DummyObject::getNestedArray()
{
    return m_nestedArray_.getRawArray();
}

const ::zserio::vector<::test_object::DummyNested>& DummyObject::getNestedArray() const
{
    return m_nestedArray_.getRawArray();
}

void DummyObject::setNestedArray(const ::zserio::vector<::test_object::DummyNested>& nestedArray_)
{
    m_nestedArray_ = ZserioArrayType_nestedArray(nestedArray_, ::zserio::ObjectArrayTraits<::test_object::DummyNested, ZserioElementFactory_nestedArray>());
}

void DummyObject::setNestedArray(::zserio::vector<::test_object::DummyNested>&& nestedArray_)
{
    m_nestedArray_ = ZserioArrayType_nestedArray(std::move(nestedArray_), ::zserio::ObjectArrayTraits<::test_object::DummyNested, ZserioElementFactory_nestedArray>());
}

::zserio::vector<::zserio::string<>>& DummyObject::getTextArray()
{
    return m_textArray_.getRawArray();
}

const ::zserio::vector<::zserio::string<>>& DummyObject::getTextArray() const
{
    return m_textArray_.getRawArray();
}

void DummyObject::setTextArray(const ::zserio::vector<::zserio::string<>>& textArray_)
{
    m_textArray_ = ZserioArrayType_textArray(textArray_, ::zserio::StringArrayTraits());
}

void DummyObject::setTextArray(::zserio::vector<::zserio::string<>>&& textArray_)
{
    m_textArray_ = ZserioArrayType_textArray(std::move(textArray_), ::zserio::StringArrayTraits());
}

::zserio::vector<::zserio::BitBuffer>& DummyObject::getExternArray()
{
    return m_externArray_.value().getRawArray();
}

const ::zserio::vector<::zserio::BitBuffer>& DummyObject::getExternArray() const
{
    return m_externArray_.value().getRawArray();
}

void DummyObject::setExternArray(const ::zserio::vector<::zserio::BitBuffer>& externArray_)
{
    m_externArray_ = ZserioArrayType_externArray(externArray_, ::zserio::BitBufferArrayTraits());
}

void DummyObject::setExternArray(::zserio::vector<::zserio::BitBuffer>&& externArray_)
{
    m_externArray_ = ZserioArrayType_externArray(std::move(externArray_), ::zserio::BitBufferArrayTraits());
}

bool DummyObject::isExternArrayUsed() const
{
    return (isExternArraySet());
}

bool DummyObject::isExternArraySet() const
{
    return m_externArray_.hasValue();
}

void DummyObject::resetExternArray()
{
    m_externArray_.reset();
}

::zserio::vector<::zserio::vector<uint8_t>>& DummyObject::getBytesArray()
{
    return m_bytesArray_.value().getRawArray();
}

const ::zserio::vector<::zserio::vector<uint8_t>>& DummyObject::getBytesArray() const
{
    return m_bytesArray_.value().getRawArray();
}

void DummyObject::setBytesArray(const ::zserio::vector<::zserio::vector<uint8_t>>& bytesArray_)
{
    m_bytesArray_ = ZserioArrayType_bytesArray(bytesArray_, ::zserio::BytesArrayTraits());
}

void DummyObject::setBytesArray(::zserio::vector<::zserio::vector<uint8_t>>&& bytesArray_)
{
    m_bytesArray_ = ZserioArrayType_bytesArray(std::move(bytesArray_), ::zserio::BytesArrayTraits());
}

bool DummyObject::isBytesArrayUsed() const
{
    return (isBytesArraySet());
}

bool DummyObject::isBytesArraySet() const
{
    return m_bytesArray_.hasValue();
}

void DummyObject::resetBytesArray()
{
    m_bytesArray_.reset();
}

bool DummyObject::getOptionalBool() const
{
    return m_optionalBool_.value();
}

void DummyObject::setOptionalBool(bool optionalBool_)
{
    m_optionalBool_ = optionalBool_;
}

bool DummyObject::isOptionalBoolUsed() const
{
    return (isOptionalBoolSet());
}

bool DummyObject::isOptionalBoolSet() const
{
    return m_optionalBool_.hasValue();
}

void DummyObject::resetOptionalBool()
{
    m_optionalBool_.reset();
}

::test_object::DummyNested& DummyObject::getOptionalNested()
{
    return m_optionalNested_.value();
}

const ::test_object::DummyNested& DummyObject::getOptionalNested() const
{
    return m_optionalNested_.value();
}

void DummyObject::setOptionalNested(const ::test_object::DummyNested& optionalNested_)
{
    m_optionalNested_ = optionalNested_;
}

void DummyObject::setOptionalNested(::test_object::DummyNested&& optionalNested_)
{
    m_optionalNested_ = ::std::move(optionalNested_);
}

bool DummyObject::isOptionalNestedUsed() const
{
    return (isOptionalNestedSet());
}

bool DummyObject::isOptionalNestedSet() const
{
    return m_optionalNested_.hasValue();
}

void DummyObject::resetOptionalNested()
{
    m_optionalNested_.reset();
}

void DummyObject::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild().createContext();
    ::test_object::DummyNested::createPackingContext(contextNode.createChild());
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild();
    ::test_object::DummyNested::createPackingContext(contextNode.createChild());
}

void DummyObject::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    contextNode.getChildren().at(0).getContext().init(
            ::zserio::StdIntArrayTraits<uint32_t>(), m_value_);
    m_nested_.initPackingContext(contextNode.getChildren().at(1));
    if (isOptionalNestedSet())
    {
        m_optionalNested_.value().initPackingContext(contextNode.getChildren().at(8));
    }
}

size_t DummyObject::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += m_nested_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += m_nestedArray_.bitSizeOf(endBitPosition);
    endBitPosition += m_textArray_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isExternArraySet())
    {
        endBitPosition += m_externArray_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isBytesArraySet())
    {
        endBitPosition += m_bytesArray_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isOptionalBoolSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isOptionalNestedSet())
    {
        endBitPosition += m_optionalNested_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DummyObject::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
            ::zserio::StdIntArrayTraits<uint32_t>(), m_value_);
    endBitPosition += m_nested_.bitSizeOf(
            contextNode.getChildren().at(1), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += m_nestedArray_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_textArray_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isExternArraySet())
    {
        endBitPosition += m_externArray_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isBytesArraySet())
    {
        endBitPosition += m_bytesArray_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isOptionalBoolSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isOptionalNestedSet())
    {
        endBitPosition += m_optionalNested_.value().bitSizeOf(
                contextNode.getChildren().at(8), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t DummyObject::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition = m_nested_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition = m_nestedArray_.initializeOffsets(
            endBitPosition);
    endBitPosition = m_textArray_.initializeOffsets(
            endBitPosition);
    endBitPosition += 1;
    if (isExternArraySet())
    {
        endBitPosition = m_externArray_.value().initializeOffsets(
                endBitPosition);
    }
    endBitPosition += 1;
    if (isBytesArraySet())
    {
        endBitPosition = m_bytesArray_.value().initializeOffsets(
                endBitPosition);
    }
    endBitPosition += 1;
    if (isOptionalBoolSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isOptionalNestedSet())
    {
        endBitPosition = m_optionalNested_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t DummyObject::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
            ::zserio::StdIntArrayTraits<uint32_t>(), m_value_);
    endBitPosition = m_nested_.initializeOffsets(
            contextNode.getChildren().at(1), endBitPosition);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition = m_nestedArray_.initializeOffsetsPacked(
            endBitPosition);
    endBitPosition = m_textArray_.initializeOffsets(
            endBitPosition);
    endBitPosition += 1;
    if (isExternArraySet())
    {
        endBitPosition = m_externArray_.value().initializeOffsets(
                endBitPosition);
    }
    endBitPosition += 1;
    if (isBytesArraySet())
    {
        endBitPosition = m_bytesArray_.value().initializeOffsets(
                endBitPosition);
    }
    endBitPosition += 1;
    if (isOptionalBoolSet())
    {
        endBitPosition += UINT8_C(1);
    }
    endBitPosition += 1;
    if (isOptionalNestedSet())
    {
        endBitPosition = m_optionalNested_.value().initializeOffsets(
                contextNode.getChildren().at(8), endBitPosition);
    }

    return endBitPosition;
}

bool DummyObject::operator==(const DummyObject& other) const
{
    if (this != &other)
    {
        return
                (m_value_ == other.m_value_) &&
                (m_nested_ == other.m_nested_) &&
                (m_text_ == other.m_text_) &&
                (m_nestedArray_ == other.m_nestedArray_) &&
                (m_textArray_ == other.m_textArray_) &&
                ((!isExternArrayUsed()) ? !other.isExternArrayUsed() : (m_externArray_ == other.m_externArray_)) &&
                ((!isBytesArrayUsed()) ? !other.isBytesArrayUsed() : (m_bytesArray_ == other.m_bytesArray_)) &&
                ((!isOptionalBoolUsed()) ? !other.isOptionalBoolUsed() : (m_optionalBool_ == other.m_optionalBool_)) &&
                ((!isOptionalNestedUsed()) ? !other.isOptionalNestedUsed() : (m_optionalNested_ == other.m_optionalNested_));
    }

    return true;
}

uint32_t DummyObject::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_value_);
    result = ::zserio::calcHashCode(result, m_nested_);
    result = ::zserio::calcHashCode(result, m_text_);
    result = ::zserio::calcHashCode(result, m_nestedArray_);
    result = ::zserio::calcHashCode(result, m_textArray_);
    if (isExternArrayUsed())
        result = ::zserio::calcHashCode(result, m_externArray_);
    if (isBytesArrayUsed())
        result = ::zserio::calcHashCode(result, m_bytesArray_);
    if (isOptionalBoolUsed())
        result = ::zserio::calcHashCode(result, m_optionalBool_);
    if (isOptionalNestedUsed())
        result = ::zserio::calcHashCode(result, m_optionalNested_);

    return result;
}

void DummyObject::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value_, UINT8_C(32));

    // check parameters
    if (m_nested_.getParam() != static_cast<uint32_t>(getValue()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter param for field DummyObject.nested: ") <<
                m_nested_.getParam() << " != " << static_cast<uint32_t>(getValue()) << "!";
    }
    m_nested_.write(out);

    out.writeString(m_text_);

    m_nestedArray_.write(out);

    m_textArray_.write(out);

    if (isExternArraySet())
    {
        out.writeBool(true);
        m_externArray_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isBytesArraySet())
    {
        out.writeBool(true);
        m_bytesArray_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isOptionalBoolSet())
    {
        out.writeBool(true);
        out.writeBool(m_optionalBool_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isOptionalNestedSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_optionalNested_.value().getParam() != static_cast<uint32_t>(getValue()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter param for field DummyObject.optionalNested: ") <<
                    m_optionalNested_.value().getParam() << " != " << static_cast<uint32_t>(getValue()) << "!";
        }
        m_optionalNested_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void DummyObject::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    contextNode.getChildren().at(0).getContext().write(
            ::zserio::StdIntArrayTraits<uint32_t>(), out, m_value_);

    // check parameters
    if (m_nested_.getParam() != static_cast<uint32_t>(getValue()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter param for field DummyObject.nested: ") <<
                m_nested_.getParam() << " != " << static_cast<uint32_t>(getValue()) << "!";
    }
    m_nested_.write(contextNode.getChildren().at(1), out);

    out.writeString(m_text_);

    m_nestedArray_.writePacked(out);

    m_textArray_.write(out);

    if (isExternArraySet())
    {
        out.writeBool(true);
        m_externArray_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isBytesArraySet())
    {
        out.writeBool(true);
        m_bytesArray_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isOptionalBoolSet())
    {
        out.writeBool(true);
        out.writeBool(m_optionalBool_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isOptionalNestedSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_optionalNested_.value().getParam() != static_cast<uint32_t>(getValue()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter param for field DummyObject.optionalNested: ") <<
                    m_optionalNested_.value().getParam() << " != " << static_cast<uint32_t>(getValue()) << "!";
        }
        m_optionalNested_.value().write(contextNode.getChildren().at(8), out);
    }
    else
    {
        out.writeBool(false);
    }
}

uint32_t DummyObject::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readBits(UINT8_C(32)));
}

uint32_t DummyObject::readValue(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return contextNode.getChildren().at(0).getContext().read(::zserio::StdIntArrayTraits<uint32_t>(), in);
}

::test_object::DummyNested DummyObject::readNested(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::test_object::DummyNested(in, static_cast<uint32_t>(getValue()), allocator);
}

::test_object::DummyNested DummyObject::readNested(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::test_object::DummyNested(contextNode.getChildren().at(1), in, static_cast<uint32_t>(getValue()), allocator);
}

::zserio::string<> DummyObject::readText(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

DummyObject::ZserioArrayType_nestedArray DummyObject::readNestedArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_nestedArray readField(::zserio::ObjectArrayTraits<::test_object::DummyNested, ZserioElementFactory_nestedArray>(), allocator);
    readField.read(in, ZserioElementFactory_nestedArray(*this));

    return readField;
}

DummyObject::ZserioArrayType_nestedArray DummyObject::readNestedArray(::zserio::PackingContextNode&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_nestedArray readField(::zserio::ObjectArrayTraits<::test_object::DummyNested, ZserioElementFactory_nestedArray>(), allocator);
    readField.readPacked(in, ZserioElementFactory_nestedArray(*this));

    return readField;
}

DummyObject::ZserioArrayType_textArray DummyObject::readTextArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_textArray readField(::zserio::StringArrayTraits(), allocator);
    readField.read(in);

    return readField;
}

::zserio::InplaceOptionalHolder<DummyObject::ZserioArrayType_externArray> DummyObject::readExternArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_externArray readField(::zserio::BitBufferArrayTraits(), allocator);
        readField.read(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_externArray>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_externArray>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<DummyObject::ZserioArrayType_bytesArray> DummyObject::readBytesArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_bytesArray readField(::zserio::BytesArrayTraits(), allocator);
        readField.read(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_bytesArray>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_bytesArray>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<bool> DummyObject::readOptionalBool(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::test_object::DummyNested> DummyObject::readOptionalNested(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::test_object::DummyNested>(::test_object::DummyNested(in, static_cast<uint32_t>(getValue()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::test_object::DummyNested>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::test_object::DummyNested> DummyObject::readOptionalNested(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::test_object::DummyNested>(::test_object::DummyNested(contextNode.getChildren().at(8), in, static_cast<uint32_t>(getValue()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::test_object::DummyNested>(::zserio::NullOpt);
}

} // namespace test_object
