/**
 * Automatically generated by Zserio C++ extension version 2.9.0-pre1.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, typeInfoCode, reflectionCode, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/TypeInfo.h>
#include <zserio/AnyHolder.h>
#include <zserio/Reflectable.h>

#include <test_object/DummyNested.h>

namespace test_object
{

DummyNested::DummyNested(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_value_(uint32_t()),
        m_text_(allocator),
        m_externData_(allocator),
        m_bytesData_(allocator),
        m_dummyEnum_(::test_object::DummyEnum()),
        m_dummyBitmask_(::test_object::DummyBitmask())
{
}

DummyNested::DummyNested(::zserio::BitStreamReader& in,
        uint32_t param_, const allocator_type& allocator) :
        m_param_(param_),
        m_isInitialized(true),
        m_value_(readValue(in)),
        m_text_(readText(in, allocator)),
        m_externData_(readExternData(in, allocator)),
        m_bytesData_(readBytesData(in, allocator)),
        m_dummyEnum_(readDummyEnum(in)),
        m_dummyBitmask_(readDummyBitmask(in))
{
}

DummyNested::DummyNested(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in,
        uint32_t param_, const allocator_type& allocator) :
        m_param_(param_),
        m_isInitialized(true),
        m_value_(readValue(contextNode, in)),
        m_text_(readText(in, allocator)),
        m_externData_(readExternData(in, allocator)),
        m_bytesData_(readBytesData(in, allocator)),
        m_dummyEnum_(readDummyEnum(contextNode, in)),
        m_dummyBitmask_(readDummyBitmask(contextNode, in))
{
}

DummyNested::DummyNested(const DummyNested& other) :
        m_value_(other.m_value_),
        m_text_(other.m_text_),
        m_externData_(other.m_externData_),
        m_bytesData_(other.m_bytesData_),
        m_dummyEnum_(other.m_dummyEnum_),
        m_dummyBitmask_(other.m_dummyBitmask_)
{
    if (other.m_isInitialized)
        initialize(other.m_param_);
    else
        m_isInitialized = false;
}

DummyNested& DummyNested::operator=(const DummyNested& other)
{
    m_value_ = other.m_value_;
    m_text_ = other.m_text_;
    m_externData_ = other.m_externData_;
    m_bytesData_ = other.m_bytesData_;
    m_dummyEnum_ = other.m_dummyEnum_;
    m_dummyBitmask_ = other.m_dummyBitmask_;
    if (other.m_isInitialized)
        initialize(other.m_param_);
    else
        m_isInitialized = false;

    return *this;
}

DummyNested::DummyNested(DummyNested&& other) :
        m_value_(::std::move(other.m_value_)),
        m_text_(::std::move(other.m_text_)),
        m_externData_(::std::move(other.m_externData_)),
        m_bytesData_(::std::move(other.m_bytesData_)),
        m_dummyEnum_(::std::move(other.m_dummyEnum_)),
        m_dummyBitmask_(::std::move(other.m_dummyBitmask_))
{
    if (other.m_isInitialized)
        initialize(other.m_param_);
    else
        m_isInitialized = false;
}

DummyNested& DummyNested::operator=(DummyNested&& other)
{
    m_value_ = ::std::move(other.m_value_);
    m_text_ = ::std::move(other.m_text_);
    m_externData_ = ::std::move(other.m_externData_);
    m_bytesData_ = ::std::move(other.m_bytesData_);
    m_dummyEnum_ = ::std::move(other.m_dummyEnum_);
    m_dummyBitmask_ = ::std::move(other.m_dummyBitmask_);
    if (other.m_isInitialized)
        initialize(other.m_param_);
    else
        m_isInitialized = false;

    return *this;
}

DummyNested::DummyNested(::zserio::PropagateAllocatorT,
        const DummyNested& other, const allocator_type& allocator) :
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator)),
        m_text_(::zserio::allocatorPropagatingCopy(other.m_text_, allocator)),
        m_externData_(::zserio::allocatorPropagatingCopy(other.m_externData_, allocator)),
        m_bytesData_(::zserio::allocatorPropagatingCopy(other.m_bytesData_, allocator)),
        m_dummyEnum_(::zserio::allocatorPropagatingCopy(other.m_dummyEnum_, allocator)),
        m_dummyBitmask_(::zserio::allocatorPropagatingCopy(other.m_dummyBitmask_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_param_);
    else
        m_isInitialized = false;
}

const ::zserio::ITypeInfo& DummyNested::typeInfo()
{
    static const ::zserio::StringView templateName;
    static const ::zserio::Span<::zserio::BasicTemplateArgumentInfo<allocator_type>> templateArguments;

    static const ::std::array<::zserio::BasicFieldInfo<allocator_type>, 6> fields = {
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("value"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getUInt32(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("text"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getString(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("externData"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getBitBuffer(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("bytesData"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getBytes(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("dummyEnum"), // schemaName
            ::zserio::enumTypeInfo<::test_object::DummyEnum, allocator_type>(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("dummyBitmask"), // schemaName
            ::test_object::DummyBitmask::typeInfo(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        }
    };

    static const ::std::array<::zserio::BasicParameterInfo<allocator_type>, 1> parameters = {
        ::zserio::BasicParameterInfo<allocator_type>{
            ::zserio::makeStringView("param"),
            ::zserio::BuiltinTypeInfo<allocator_type>::getUInt32()
        }
    };

    static const ::zserio::Span<::zserio::BasicFunctionInfo<allocator_type>> functions;

    static const ::zserio::StructTypeInfo<allocator_type> typeInfo = {
        ::zserio::makeStringView("test_object.DummyNested"),
        [](const allocator_type& allocator) -> ::zserio::IReflectablePtr
        {
            return std::allocate_shared<::zserio::ReflectableOwner<DummyNested>>(allocator, allocator);
        },
        templateName, templateArguments,
        fields, parameters, functions
    };

    return typeInfo;
}

::zserio::IReflectableConstPtr DummyNested::reflectable(const allocator_type& allocator) const
{
    class Reflectable : public ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>
    {
    public:
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getField;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getParameter;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::callFunction;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getAnyValue;

        explicit Reflectable(const ::test_object::DummyNested& object, const allocator_type& allocator) :
                ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>(::test_object::DummyNested::typeInfo(), allocator),
                m_object(object)
        {}

        virtual size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_object.bitSizeOf(bitPosition);
        }

        virtual void write(::zserio::BitStreamWriter& writer) const override
        {
            m_object.write(writer);
        }

        virtual ::zserio::IReflectableConstPtr getField(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                return ::zserio::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                return ::zserio::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externData"))
            {
                return ::zserio::ReflectableFactory::getBitBuffer(m_object.getExternData(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesData"))
            {
                return ::zserio::ReflectableFactory::getBytes(m_object.getBytesData(), get_allocator());
            }
            if (name == ::zserio::makeStringView("dummyEnum"))
            {
                return ::zserio::enumReflectable(m_object.getDummyEnum(), get_allocator());
            }
            if (name == ::zserio::makeStringView("dummyBitmask"))
            {
                return m_object.getDummyBitmask().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'DummyNested'!";
        }

        virtual ::zserio::IReflectableConstPtr getParameter(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("param"))
            {
                return ::zserio::ReflectableFactory::getUInt32(m_object.getParam(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Parameter '") << name << "' doesn't exist in 'DummyNested'!";
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const allocator_type& allocator) const override
        {
            return ::zserio::AnyHolder<>(::std::cref(m_object), allocator);
        }

    private:
        const ::test_object::DummyNested& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, *this, allocator);
}

::zserio::IReflectablePtr DummyNested::reflectable(const allocator_type& allocator)
{
    class Reflectable : public ::zserio::ReflectableAllocatorHolderBase<allocator_type>
    {
    public:
        explicit Reflectable(::test_object::DummyNested& object, const allocator_type& allocator) :
                ::zserio::ReflectableAllocatorHolderBase<allocator_type>(::test_object::DummyNested::typeInfo(), allocator),
                m_object(object)
        {}

        virtual void initializeChildren() override
        {
        }

        virtual void initialize(
                const ::zserio::vector<::zserio::AnyHolder<allocator_type>, allocator_type>& typeArguments) override
        {
            if (typeArguments.size() != 1)
            {
                throw ::zserio::CppRuntimeException("Not enough arguments to DummyNested::initialize, ") <<
                        "expecting 1, got " << typeArguments.size();
            }

            m_object.initialize(
                typeArguments[0].get<uint32_t>()
            );
        }

        virtual size_t initializeOffsets(size_t bitPosition) override
        {
            return m_object.initializeOffsets(bitPosition);
        }

        virtual size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_object.bitSizeOf(bitPosition);
        }

        virtual void write(::zserio::BitStreamWriter& writer) const override
        {
            m_object.write(writer);
        }

        virtual ::zserio::IReflectableConstPtr getField(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                return ::zserio::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                return ::zserio::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externData"))
            {
                return ::zserio::ReflectableFactory::getBitBuffer(m_object.getExternData(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesData"))
            {
                return ::zserio::ReflectableFactory::getBytes(m_object.getBytesData(), get_allocator());
            }
            if (name == ::zserio::makeStringView("dummyEnum"))
            {
                return ::zserio::enumReflectable(m_object.getDummyEnum(), get_allocator());
            }
            if (name == ::zserio::makeStringView("dummyBitmask"))
            {
                return m_object.getDummyBitmask().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'DummyNested'!";
        }

        virtual ::zserio::IReflectablePtr getField(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                return ::zserio::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                return ::zserio::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externData"))
            {
                return ::zserio::ReflectableFactory::getBitBuffer(m_object.getExternData(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesData"))
            {
                return ::zserio::ReflectableFactory::getBytes(m_object.getBytesData(), get_allocator());
            }
            if (name == ::zserio::makeStringView("dummyEnum"))
            {
                return ::zserio::enumReflectable(m_object.getDummyEnum(), get_allocator());
            }
            if (name == ::zserio::makeStringView("dummyBitmask"))
            {
                return m_object.getDummyBitmask().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'DummyNested'!";
        }

        virtual void setField(::zserio::StringView name,
                const ::zserio::AnyHolder<allocator_type>& value) override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                m_object.setValue(value.get<uint32_t>());
                return;
            }
            if (name == ::zserio::makeStringView("text"))
            {
                m_object.setText(value.get<::zserio::string<>>());
                return;
            }
            if (name == ::zserio::makeStringView("externData"))
            {
                m_object.setExternData(value.get<::zserio::BitBuffer>());
                return;
            }
            if (name == ::zserio::makeStringView("bytesData"))
            {
                m_object.setBytesData(value.get<::zserio::vector<uint8_t>>());
                return;
            }
            if (name == ::zserio::makeStringView("dummyEnum"))
            {
                if (value.isType<::test_object::DummyEnum>())
                {
                    m_object.setDummyEnum(value.get<::test_object::DummyEnum>());
                }
                else
                {
                    m_object.setDummyEnum(::zserio::valueToEnum<::test_object::DummyEnum>(
                            value.get<typename ::std::underlying_type<::test_object::DummyEnum>::type>()));
                }
                return;
            }
            if (name == ::zserio::makeStringView("dummyBitmask"))
            {
                if (value.isType<::test_object::DummyBitmask>())
                {
                    m_object.setDummyBitmask(value.get<::test_object::DummyBitmask>());
                }
                else
                {
                    m_object.setDummyBitmask(::test_object::DummyBitmask(
                            value.get<::test_object::DummyBitmask::underlying_type>()));
                }
                return;
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'DummyNested'!";
        }

        virtual ::zserio::IReflectablePtr createField(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("value"))
            {
                m_object.setValue(uint32_t());
                return ::zserio::ReflectableFactory::getUInt32(m_object.getValue(), get_allocator());
            }
            if (name == ::zserio::makeStringView("text"))
            {
                m_object.setText(::zserio::string<>(get_allocator()));
                return ::zserio::ReflectableFactory::getString(m_object.getText(), get_allocator());
            }
            if (name == ::zserio::makeStringView("externData"))
            {
                m_object.setExternData(::zserio::BitBuffer(get_allocator()));
                return ::zserio::ReflectableFactory::getBitBuffer(m_object.getExternData(), get_allocator());
            }
            if (name == ::zserio::makeStringView("bytesData"))
            {
                m_object.setBytesData(::zserio::vector<uint8_t>(get_allocator()));
                return ::zserio::ReflectableFactory::getBytes(m_object.getBytesData(), get_allocator());
            }
            if (name == ::zserio::makeStringView("dummyEnum"))
            {
                m_object.setDummyEnum(::test_object::DummyEnum());
                return ::zserio::enumReflectable(m_object.getDummyEnum(), get_allocator());
            }
            if (name == ::zserio::makeStringView("dummyBitmask"))
            {
                m_object.setDummyBitmask(::test_object::DummyBitmask());
                return m_object.getDummyBitmask().reflectable(get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'DummyNested'!";
        }

        virtual ::zserio::IReflectableConstPtr getParameter(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("param"))
            {
                return ::zserio::ReflectableFactory::getUInt32(m_object.getParam(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Parameter '") << name << "' doesn't exist in 'DummyNested'!";
        }

        virtual ::zserio::IReflectablePtr getParameter(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("param"))
            {
                return ::zserio::ReflectableFactory::getUInt32(m_object.getParam(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Parameter '") << name << "' doesn't exist in 'DummyNested'!";
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const allocator_type& allocator) const override
        {
            return ::zserio::AnyHolder<>(::std::cref(m_object), allocator);
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const allocator_type& allocator) override
        {
            return ::zserio::AnyHolder<>(::std::ref(m_object), allocator);
        }

    private:
        ::test_object::DummyNested& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, *this, allocator);
}

void DummyNested::initialize(
        uint32_t param_)
{
    m_param_ = param_;
    m_isInitialized = true;
}

bool DummyNested::isInitialized() const
{
    return m_isInitialized;
}

uint32_t DummyNested::getParam() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'param' of compound 'DummyNested' is not initialized!");

    return m_param_;
}

uint32_t DummyNested::getValue() const
{
    return m_value_;
}

void DummyNested::setValue(uint32_t value_)
{
    m_value_ = value_;
}

::zserio::string<>& DummyNested::getText()
{
    return m_text_;
}

const ::zserio::string<>& DummyNested::getText() const
{
    return m_text_;
}

void DummyNested::setText(const ::zserio::string<>& text_)
{
    m_text_ = text_;
}

void DummyNested::setText(::zserio::string<>&& text_)
{
    m_text_ = ::std::move(text_);
}

::zserio::BitBuffer& DummyNested::getExternData()
{
    return m_externData_;
}

const ::zserio::BitBuffer& DummyNested::getExternData() const
{
    return m_externData_;
}

void DummyNested::setExternData(const ::zserio::BitBuffer& externData_)
{
    m_externData_ = externData_;
}

void DummyNested::setExternData(::zserio::BitBuffer&& externData_)
{
    m_externData_ = ::std::move(externData_);
}

::zserio::vector<uint8_t>& DummyNested::getBytesData()
{
    return m_bytesData_;
}

const ::zserio::vector<uint8_t>& DummyNested::getBytesData() const
{
    return m_bytesData_;
}

void DummyNested::setBytesData(const ::zserio::vector<uint8_t>& bytesData_)
{
    m_bytesData_ = bytesData_;
}

void DummyNested::setBytesData(::zserio::vector<uint8_t>&& bytesData_)
{
    m_bytesData_ = ::std::move(bytesData_);
}

::test_object::DummyEnum DummyNested::getDummyEnum() const
{
    return m_dummyEnum_;
}

void DummyNested::setDummyEnum(::test_object::DummyEnum dummyEnum_)
{
    m_dummyEnum_ = dummyEnum_;
}

::test_object::DummyBitmask DummyNested::getDummyBitmask() const
{
    return m_dummyBitmask_;
}

void DummyNested::setDummyBitmask(::test_object::DummyBitmask dummyBitmask_)
{
    m_dummyBitmask_ = dummyBitmask_;
}

void DummyNested::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild().createContext();
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild().createContext();
    ::test_object::DummyBitmask::createPackingContext(contextNode.createChild());
}

void DummyNested::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    contextNode.getChildren().at(0).getContext().init(
            ::zserio::StdIntArrayTraits<uint32_t>(), m_value_);
    ::zserio::initPackingContext(contextNode.getChildren().at(4),
            m_dummyEnum_);
    m_dummyBitmask_.initPackingContext(contextNode.getChildren().at(5));
}

size_t DummyNested::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_externData_);
    endBitPosition += ::zserio::bitSizeOfBytes(m_bytesData_);
    endBitPosition += ::zserio::bitSizeOf(m_dummyEnum_);
    endBitPosition += m_dummyBitmask_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DummyNested::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
            ::zserio::StdIntArrayTraits<uint32_t>(), m_value_);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_externData_);
    endBitPosition += ::zserio::bitSizeOfBytes(m_bytesData_);
    endBitPosition += ::zserio::bitSizeOf(
            contextNode.getChildren().at(4), m_dummyEnum_);
    endBitPosition += m_dummyBitmask_.bitSizeOf(
            contextNode.getChildren().at(5), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t DummyNested::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_externData_);
    endBitPosition += ::zserio::bitSizeOfBytes(m_bytesData_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_dummyEnum_);
    endBitPosition = m_dummyBitmask_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t DummyNested::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
            ::zserio::StdIntArrayTraits<uint32_t>(), m_value_);
    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_externData_);
    endBitPosition += ::zserio::bitSizeOfBytes(m_bytesData_);
    endBitPosition = ::zserio::initializeOffsets(
            contextNode.getChildren().at(4), endBitPosition, m_dummyEnum_);
    endBitPosition = m_dummyBitmask_.initializeOffsets(
            contextNode.getChildren().at(5), endBitPosition);

    return endBitPosition;
}

bool DummyNested::operator==(const DummyNested& other) const
{
    if (this != &other)
    {
        return
                (getParam() == other.getParam()) &&
                (m_value_ == other.m_value_) &&
                (m_text_ == other.m_text_) &&
                (m_externData_ == other.m_externData_) &&
                (m_bytesData_ == other.m_bytesData_) &&
                (m_dummyEnum_ == other.m_dummyEnum_) &&
                (m_dummyBitmask_ == other.m_dummyBitmask_);
    }

    return true;
}

uint32_t DummyNested::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getParam());
    result = ::zserio::calcHashCode(result, m_value_);
    result = ::zserio::calcHashCode(result, m_text_);
    result = ::zserio::calcHashCode(result, m_externData_);
    result = ::zserio::calcHashCode(result, m_bytesData_);
    result = ::zserio::calcHashCode(result, m_dummyEnum_);
    result = ::zserio::calcHashCode(result, m_dummyBitmask_);

    return result;
}

void DummyNested::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value_, UINT8_C(32));
    out.writeString(m_text_);
    out.writeBitBuffer(m_externData_);
    out.writeBytes(m_bytesData_);
    ::zserio::write(out, m_dummyEnum_);
    m_dummyBitmask_.write(out);
}

void DummyNested::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    contextNode.getChildren().at(0).getContext().write(
            ::zserio::StdIntArrayTraits<uint32_t>(), out, m_value_);
    out.writeString(m_text_);
    out.writeBitBuffer(m_externData_);
    out.writeBytes(m_bytesData_);
    ::zserio::write(contextNode.getChildren().at(4), out, m_dummyEnum_);
    m_dummyBitmask_.write(contextNode.getChildren().at(5), out);
}

uint32_t DummyNested::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readBits(UINT8_C(32)));
}

uint32_t DummyNested::readValue(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return contextNode.getChildren().at(0).getContext().read(::zserio::StdIntArrayTraits<uint32_t>(), in);
}

::zserio::string<> DummyNested::readText(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

::zserio::BitBuffer DummyNested::readExternData(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::BitBuffer>(in.readBitBuffer(allocator));
}

::zserio::vector<uint8_t> DummyNested::readBytesData(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::vector<uint8_t>>(in.readBytes(allocator));
}

::test_object::DummyEnum DummyNested::readDummyEnum(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::test_object::DummyEnum>(in);
}

::test_object::DummyEnum DummyNested::readDummyEnum(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::test_object::DummyEnum>(contextNode.getChildren().at(4), in);
}

::test_object::DummyBitmask DummyNested::readDummyBitmask(::zserio::BitStreamReader& in)
{
    return ::test_object::DummyBitmask(in);
}

::test_object::DummyBitmask DummyNested::readDummyBitmask(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return ::test_object::DummyBitmask(contextNode.getChildren().at(5), in);
}

} // namespace test_object
