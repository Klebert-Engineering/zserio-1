/**
 * Automatically generated by Zserio C++ extension version 2.9.0-pre1.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, typeInfoCode, reflectionCode, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/TypeInfo.h>
#include <zserio/AnyHolder.h>
#include <zserio/Reflectable.h>

#include <test_object/WalkerBitmask.h>

namespace test_object
{

WalkerBitmask::WalkerBitmask(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

WalkerBitmask::WalkerBitmask(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in) :
        m_value(readValue(contextNode, in))
{}

const ::zserio::ITypeInfo& WalkerBitmask::typeInfo()
{
    using allocator_type = ::std::allocator<uint8_t>;

    static const ::zserio::Span<::zserio::StringView> underlyingTypeArguments;

    static const ::std::array<::zserio::ItemInfo, 1> values = {
        ::zserio::ItemInfo{ ::zserio::makeStringView("ZERO"), static_cast<uint64_t>(UINT32_C(1)) }
    };

    static const ::zserio::BitmaskTypeInfo<allocator_type> typeInfo = {
        ::zserio::makeStringView("test_object.WalkerBitmask"),
        ::zserio::BuiltinTypeInfo<allocator_type>::getUInt32(), underlyingTypeArguments, values
    };

    return typeInfo;
}

::zserio::IReflectablePtr WalkerBitmask::reflectable(const ::std::allocator<uint8_t>& allocator) const
{
    class Reflectable : public ::zserio::ReflectableBase<::std::allocator<uint8_t>>
    {
    public:
        explicit Reflectable(::test_object::WalkerBitmask bitmask) :
                ::zserio::ReflectableBase<::std::allocator<uint8_t>>(::test_object::WalkerBitmask::typeInfo()),
                m_bitmask(bitmask)
        {}

        virtual size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_bitmask.bitSizeOf(bitPosition);
        }

        virtual void write(::zserio::BitStreamWriter& writer) const override
        {
            m_bitmask.write(writer);
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const ::std::allocator<uint8_t>& allocator) const override
        {
            return ::zserio::AnyHolder<>(m_bitmask, allocator);
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const ::std::allocator<uint8_t>& allocator) override
        {
            return ::zserio::AnyHolder<>(m_bitmask, allocator);
        }

        virtual uint32_t getUInt32() const override
        {
            return m_bitmask.getValue();
        }

        virtual uint64_t toUInt() const override
        {
            return m_bitmask.getValue();
        }

        virtual double toDouble() const override
        {
            return static_cast<double>(toUInt());
        }

        virtual ::zserio::string<> toString(
                const ::std::allocator<uint8_t>& allocator = ::std::allocator<uint8_t>()) const override
        {
            return m_bitmask.toString(allocator);
        }

    private:
        ::test_object::WalkerBitmask m_bitmask;
    };

    return ::std::allocate_shared<Reflectable>(allocator, *this);
}

void WalkerBitmask::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createContext();
}

void WalkerBitmask::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    contextNode.getContext().init(::zserio::StdIntArrayTraits<::test_object::WalkerBitmask::underlying_type>(),
            m_value);
}

size_t WalkerBitmask::bitSizeOf(size_t) const
{
    return UINT8_C(32);
}

size_t WalkerBitmask::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t) const
{
    return contextNode.getContext().bitSizeOf(
            ::zserio::StdIntArrayTraits<::test_object::WalkerBitmask::underlying_type>(),
            m_value);
}

size_t WalkerBitmask::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t WalkerBitmask::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(contextNode, bitPosition);
}

uint32_t WalkerBitmask::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void WalkerBitmask::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(32));
}

void WalkerBitmask::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    contextNode.getContext().write(
            ::zserio::StdIntArrayTraits<::test_object::WalkerBitmask::underlying_type>(),
            out, m_value);
}

::zserio::string<> WalkerBitmask::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & WalkerBitmask::Values::ZERO) == WalkerBitmask::Values::ZERO)
        result += result.empty() ? "ZERO" : " | ZERO";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

WalkerBitmask::underlying_type WalkerBitmask::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(32)));
}

WalkerBitmask::underlying_type WalkerBitmask::readValue(::zserio::PackingContextNode& contextNode,
        ::zserio::BitStreamReader& in)
{
    return contextNode.getContext().read(
            ::zserio::StdIntArrayTraits<::test_object::WalkerBitmask::underlying_type>(), in);
}

} // namespace test_object
