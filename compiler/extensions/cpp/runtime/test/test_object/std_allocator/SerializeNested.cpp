/**
 * Automatically generated by Zserio C++ extension version 2.9.0-pre1.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, typeInfoCode, reflectionCode, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/TypeInfo.h>
#include <zserio/AnyHolder.h>
#include <zserio/Reflectable.h>

#include <test_object/std_allocator/SerializeNested.h>

namespace test_object
{
namespace std_allocator
{

SerializeNested::SerializeNested(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_offset_(uint8_t()),
        m_optionalValue_(::zserio::NullOpt)
{
}

SerializeNested::SerializeNested(::zserio::BitStreamReader& in,
        int8_t param_, const allocator_type&) :
        m_param_(param_),
        m_isInitialized(true),
        m_offset_(readOffset(in)),
        m_optionalValue_(readOptionalValue(in))
{
}

SerializeNested::SerializeNested(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in,
        int8_t param_, const allocator_type&) :
        m_param_(param_),
        m_isInitialized(true),
        m_offset_(readOffset(in)),
        m_optionalValue_(readOptionalValue(contextNode, in))
{
}

SerializeNested::SerializeNested(const SerializeNested& other) :
        m_offset_(other.m_offset_),
        m_optionalValue_(other.m_optionalValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_param_);
    else
        m_isInitialized = false;
}

SerializeNested& SerializeNested::operator=(const SerializeNested& other)
{
    m_offset_ = other.m_offset_;
    m_optionalValue_ = other.m_optionalValue_;
    if (other.m_isInitialized)
        initialize(other.m_param_);
    else
        m_isInitialized = false;

    return *this;
}

SerializeNested::SerializeNested(SerializeNested&& other) :
        m_offset_(::std::move(other.m_offset_)),
        m_optionalValue_(::std::move(other.m_optionalValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_param_);
    else
        m_isInitialized = false;
}

SerializeNested& SerializeNested::operator=(SerializeNested&& other)
{
    m_offset_ = ::std::move(other.m_offset_);
    m_optionalValue_ = ::std::move(other.m_optionalValue_);
    if (other.m_isInitialized)
        initialize(other.m_param_);
    else
        m_isInitialized = false;

    return *this;
}

SerializeNested::SerializeNested(::zserio::PropagateAllocatorT,
        const SerializeNested& other, const allocator_type& allocator) :
        m_offset_(::zserio::allocatorPropagatingCopy(other.m_offset_, allocator)),
        m_optionalValue_(::zserio::allocatorPropagatingCopy(other.m_optionalValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_param_);
    else
        m_isInitialized = false;
}

const ::zserio::ITypeInfo& SerializeNested::typeInfo()
{
    static const ::zserio::StringView templateName;
    static const ::zserio::Span<::zserio::BasicTemplateArgumentInfo<allocator_type>> templateArguments;

    static const ::std::array<::zserio::BasicFieldInfo<allocator_type>, 2> fields = {
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("offset"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getUInt8(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<allocator_type>{
            ::zserio::makeStringView("optionalValue"), // schemaName
            ::zserio::BuiltinTypeInfo<allocator_type>::getUInt32(), // typeInfo
            {}, // typeArguments
            {}, // alignment
            ::zserio::makeStringView("getOffset()"), // offset
            {}, // initializer
            true, // isOptional
            ::zserio::makeStringView("getParam() >= 0"), // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        }
    };

    static const ::std::array<::zserio::BasicParameterInfo<allocator_type>, 1> parameters = {
        ::zserio::BasicParameterInfo<allocator_type>{
            ::zserio::makeStringView("param"),
            ::zserio::BuiltinTypeInfo<allocator_type>::getInt8()
        }
    };

    static const ::zserio::Span<::zserio::BasicFunctionInfo<allocator_type>> functions;

    static const ::zserio::StructTypeInfo<allocator_type> typeInfo = {
        ::zserio::makeStringView("test_object.std_allocator.SerializeNested"),
        [](const allocator_type& allocator) -> ::zserio::IReflectablePtr
        {
            return std::allocate_shared<::zserio::ReflectableOwner<SerializeNested>>(allocator, allocator);
        },
        templateName, templateArguments,
        fields, parameters, functions
    };

    return typeInfo;
}

::zserio::IReflectableConstPtr SerializeNested::reflectable(const allocator_type& allocator) const
{
    class Reflectable : public ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>
    {
    public:
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getField;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getParameter;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::callFunction;
        using ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>::getAnyValue;

        explicit Reflectable(const ::test_object::std_allocator::SerializeNested& object, const allocator_type& allocator) :
                ::zserio::ReflectableConstAllocatorHolderBase<allocator_type>(::test_object::std_allocator::SerializeNested::typeInfo(), allocator),
                m_object(object)
        {}

        virtual size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_object.bitSizeOf(bitPosition);
        }

        virtual void write(::zserio::BitStreamWriter& writer) const override
        {
            m_object.write(writer);
        }

        virtual ::zserio::IReflectableConstPtr getField(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("offset"))
            {
                return ::zserio::ReflectableFactory::getUInt8(m_object.getOffset(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalValue"))
            {
                if (!m_object.isOptionalValueSet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getUInt32(m_object.getOptionalValue(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'SerializeNested'!";
        }

        virtual ::zserio::IReflectableConstPtr getParameter(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("param"))
            {
                return ::zserio::ReflectableFactory::getInt8(m_object.getParam(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Parameter '") << name << "' doesn't exist in 'SerializeNested'!";
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const allocator_type& allocator) const override
        {
            return ::zserio::AnyHolder<>(::std::cref(m_object), allocator);
        }

    private:
        const ::test_object::std_allocator::SerializeNested& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, *this, allocator);
}

::zserio::IReflectablePtr SerializeNested::reflectable(const allocator_type& allocator)
{
    class Reflectable : public ::zserio::ReflectableAllocatorHolderBase<allocator_type>
    {
    public:
        explicit Reflectable(::test_object::std_allocator::SerializeNested& object, const allocator_type& allocator) :
                ::zserio::ReflectableAllocatorHolderBase<allocator_type>(::test_object::std_allocator::SerializeNested::typeInfo(), allocator),
                m_object(object)
        {}

        virtual void initializeChildren() override
        {
        }

        virtual void initialize(
                const ::zserio::vector<::zserio::AnyHolder<allocator_type>, allocator_type>& typeArguments) override
        {
            if (typeArguments.size() != 1)
            {
                throw ::zserio::CppRuntimeException("Not enough arguments to SerializeNested::initialize, ") <<
                        "expecting 1, got " << typeArguments.size();
            }

            m_object.initialize(
                typeArguments[0].get<int8_t>()
            );
        }

        virtual size_t initializeOffsets(size_t bitPosition) override
        {
            return m_object.initializeOffsets(bitPosition);
        }

        virtual size_t bitSizeOf(size_t bitPosition) const override
        {
            return m_object.bitSizeOf(bitPosition);
        }

        virtual void write(::zserio::BitStreamWriter& writer) const override
        {
            m_object.write(writer);
        }

        virtual ::zserio::IReflectableConstPtr getField(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("offset"))
            {
                return ::zserio::ReflectableFactory::getUInt8(m_object.getOffset(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalValue"))
            {
                if (!m_object.isOptionalValueSet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getUInt32(m_object.getOptionalValue(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'SerializeNested'!";
        }

        virtual ::zserio::IReflectablePtr getField(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("offset"))
            {
                return ::zserio::ReflectableFactory::getUInt8(m_object.getOffset(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalValue"))
            {
                if (!m_object.isOptionalValueSet())
                    return nullptr;

                return ::zserio::ReflectableFactory::getUInt32(m_object.getOptionalValue(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'SerializeNested'!";
        }

        virtual void setField(::zserio::StringView name,
                const ::zserio::AnyHolder<allocator_type>& value) override
        {
            if (name == ::zserio::makeStringView("offset"))
            {
                m_object.setOffset(value.get<uint8_t>());
                return;
            }
            if (name == ::zserio::makeStringView("optionalValue"))
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.resetOptionalValue();
                    return;
                }

                m_object.setOptionalValue(value.get<uint32_t>());
                return;
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'SerializeNested'!";
        }

        virtual ::zserio::IReflectablePtr createField(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("offset"))
            {
                m_object.setOffset(uint8_t());
                return ::zserio::ReflectableFactory::getUInt8(m_object.getOffset(), get_allocator());
            }
            if (name == ::zserio::makeStringView("optionalValue"))
            {
                m_object.setOptionalValue(uint32_t());
                return ::zserio::ReflectableFactory::getUInt32(m_object.getOptionalValue(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'SerializeNested'!";
        }

        virtual ::zserio::IReflectableConstPtr getParameter(::zserio::StringView name) const override
        {
            if (name == ::zserio::makeStringView("param"))
            {
                return ::zserio::ReflectableFactory::getInt8(m_object.getParam(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Parameter '") << name << "' doesn't exist in 'SerializeNested'!";
        }

        virtual ::zserio::IReflectablePtr getParameter(::zserio::StringView name) override
        {
            if (name == ::zserio::makeStringView("param"))
            {
                return ::zserio::ReflectableFactory::getInt8(m_object.getParam(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Parameter '") << name << "' doesn't exist in 'SerializeNested'!";
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const allocator_type& allocator) const override
        {
            return ::zserio::AnyHolder<>(::std::cref(m_object), allocator);
        }

        virtual ::zserio::AnyHolder<> getAnyValue(const allocator_type& allocator) override
        {
            return ::zserio::AnyHolder<>(::std::ref(m_object), allocator);
        }

    private:
        ::test_object::std_allocator::SerializeNested& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, *this, allocator);
}

void SerializeNested::initialize(
        int8_t param_)
{
    m_param_ = param_;
    m_isInitialized = true;
}

bool SerializeNested::isInitialized() const
{
    return m_isInitialized;
}

int8_t SerializeNested::getParam() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'param' of compound 'SerializeNested' is not initialized!");

    return m_param_;
}

uint8_t SerializeNested::getOffset() const
{
    return m_offset_;
}

void SerializeNested::setOffset(uint8_t offset_)
{
    m_offset_ = offset_;
}

uint32_t SerializeNested::getOptionalValue() const
{
    return m_optionalValue_.value();
}

void SerializeNested::setOptionalValue(uint32_t optionalValue_)
{
    m_optionalValue_ = optionalValue_;
}

bool SerializeNested::isOptionalValueUsed() const
{
    return (getParam() >= 0);
}

bool SerializeNested::isOptionalValueSet() const
{
    return m_optionalValue_.hasValue();
}

void SerializeNested::resetOptionalValue()
{
    m_optionalValue_.reset();
}

void SerializeNested::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild();
    contextNode.createChild().createContext();
}

void SerializeNested::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    if (getParam() >= 0)
    {
        contextNode.getChildren().at(1).getContext().init(
                ::zserio::StdIntArrayTraits<uint32_t>(), m_optionalValue_.value());
    }
}

size_t SerializeNested::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getParam() >= 0)
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += UINT8_C(32);
    }

    return endBitPosition - bitPosition;
}

size_t SerializeNested::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getParam() >= 0)
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += contextNode.getChildren().at(1).getContext().bitSizeOf(
                ::zserio::StdIntArrayTraits<uint32_t>(), m_optionalValue_.value());
    }

    return endBitPosition - bitPosition;
}

size_t SerializeNested::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getParam() >= 0)
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        {
            const uint8_t value =
                    static_cast<uint8_t>(::zserio::bitsToBytes(endBitPosition));
            setOffset(value);
        }
        endBitPosition += UINT8_C(32);
    }

    return endBitPosition;
}

size_t SerializeNested::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getParam() >= 0)
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        {
            const uint8_t value =
                    static_cast<uint8_t>(::zserio::bitsToBytes(endBitPosition));
            setOffset(value);
        }
        endBitPosition += contextNode.getChildren().at(1).getContext().bitSizeOf(
                ::zserio::StdIntArrayTraits<uint32_t>(), m_optionalValue_.value());
    }

    return endBitPosition;
}

bool SerializeNested::operator==(const SerializeNested& other) const
{
    if (this != &other)
    {
        return
                (getParam() == other.getParam()) &&
                (m_offset_ == other.m_offset_) &&
                ((!isOptionalValueUsed()) ? !other.isOptionalValueUsed() : (m_optionalValue_ == other.m_optionalValue_));
    }

    return true;
}

uint32_t SerializeNested::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getParam());
    result = ::zserio::calcHashCode(result, m_offset_);
    if (isOptionalValueUsed())
        result = ::zserio::calcHashCode(result, m_optionalValue_);

    return result;
}

void SerializeNested::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_offset_, UINT8_C(8));

    if (getParam() >= 0)
    {
        out.alignTo(UINT32_C(8));
        // check offset
        if (::zserio::bitsToBytes(out.getBitPosition()) != (getOffset()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong offset for field SerializeNested.optionalValue: ") <<
                    ::zserio::bitsToBytes(out.getBitPosition()) << " != " << (getOffset()) << "!";
        }
        out.writeBits(m_optionalValue_.value(), UINT8_C(32));
    }
}

void SerializeNested::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_offset_, UINT8_C(8));

    if (getParam() >= 0)
    {
        out.alignTo(UINT32_C(8));
        // check offset
        if (::zserio::bitsToBytes(out.getBitPosition()) != (getOffset()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong offset for field SerializeNested.optionalValue: ") <<
                    ::zserio::bitsToBytes(out.getBitPosition()) << " != " << (getOffset()) << "!";
        }
        contextNode.getChildren().at(1).getContext().write(
                ::zserio::StdIntArrayTraits<uint32_t>(), out, m_optionalValue_.value());
    }
}

uint8_t SerializeNested::readOffset(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

::zserio::InplaceOptionalHolder<uint32_t> SerializeNested::readOptionalValue(::zserio::BitStreamReader& in)
{
    if (getParam() >= 0)
    {
        in.alignTo(UINT32_C(8));
        // check offset
        if (::zserio::bitsToBytes(in.getBitPosition()) != (getOffset()))
        {
            throw ::zserio::CppRuntimeException("Read: Wrong offset for field SerializeNested.optionalValue: ") <<
                    ::zserio::bitsToBytes(in.getBitPosition()) << " != " << (getOffset()) << "!";
        }
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readBits(UINT8_C(32))));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> SerializeNested::readOptionalValue(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (getParam() >= 0)
    {
        in.alignTo(UINT32_C(8));
        // check offset
        if (::zserio::bitsToBytes(in.getBitPosition()) != (getOffset()))
        {
            throw ::zserio::CppRuntimeException("Read: Wrong offset for field SerializeNested.optionalValue: ") <<
                    ::zserio::bitsToBytes(in.getBitPosition()) << " != " << (getOffset()) << "!";
        }
        return ::zserio::InplaceOptionalHolder<uint32_t>(contextNode.getChildren().at(1).getContext().read(::zserio::StdIntArrayTraits<uint32_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

} // namespace std_allocator
} // namespace test_object
