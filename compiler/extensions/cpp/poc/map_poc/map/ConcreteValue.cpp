/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <map/ConcreteValue.h>

namespace map
{

ConcreteValue::ConcreteValue() noexcept :
        m_isInitialized(false)
{
}

ConcreteValue::ConcreteValue(::zserio::BitStreamReader& in,
        ::map::ConcreteType type_) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in))
{
}

ConcreteValue::ConcreteValue(const ConcreteValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ConcreteValue& ConcreteValue::operator=(const ConcreteValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

ConcreteValue::ConcreteValue(ConcreteValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

ConcreteValue& ConcreteValue::operator=(ConcreteValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

void ConcreteValue::initialize(
        ::map::ConcreteType type_)
{
    m_type_ = type_;
    m_isInitialized = true;
}

bool ConcreteValue::isInitialized() const
{
    return m_isInitialized;
}

::map::ConcreteType ConcreteValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter type of compound ConcreteValue "
                "is not initialized!");

    return m_type_;
}

uint32_t ConcreteValue::getValueU32() const
{
    return m_objectChoice.get<uint32_t>();
}

void ConcreteValue::setValueU32(uint32_t valueU32_)
{
    m_objectChoice = valueU32_;
}

::std::string& ConcreteValue::getValueString()
{
    return m_objectChoice.get<::std::string>();
}

const ::std::string& ConcreteValue::getValueString() const
{
    return m_objectChoice.get<::std::string>();
}

void ConcreteValue::setValueString(const ::std::string& valueString_)
{
    m_objectChoice = valueString_;
}

void ConcreteValue::setValueString(::std::string&& valueString_)
{
    m_objectChoice = ::std::move(valueString_);
}

double ConcreteValue::getValueDouble() const
{
    return m_objectChoice.get<double>();
}

void ConcreteValue::setValueDouble(double valueDouble_)
{
    m_objectChoice = valueDouble_;
}

size_t ConcreteValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::map::ConcreteType::U32:
        endBitPosition += UINT8_C(32);
        break;
    case ::map::ConcreteType::STRING:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::std::string>());
        break;
    case ::map::ConcreteType::DOUBLE:
        endBitPosition += UINT8_C(64);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ConcreteValue!");
    }

    return endBitPosition - bitPosition;
}

size_t ConcreteValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::map::ConcreteType::U32:
        endBitPosition += UINT8_C(32);
        break;
    case ::map::ConcreteType::STRING:
        endBitPosition += ::zserio::bitSizeOfString(m_objectChoice.get<::std::string>());
        break;
    case ::map::ConcreteType::DOUBLE:
        endBitPosition += UINT8_C(64);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ConcreteValue!");
    }

    return endBitPosition;
}

bool ConcreteValue::operator==(const ConcreteValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::map::ConcreteType::U32:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<uint32_t>() == other.m_objectChoice.get<uint32_t>());
    case ::map::ConcreteType::STRING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::std::string>() == other.m_objectChoice.get<::std::string>());
    case ::map::ConcreteType::DOUBLE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<double>() == other.m_objectChoice.get<double>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice ConcreteValue!");
    }
}

int ConcreteValue::hashCode() const
{
    int result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    switch (getType())
    {
    case ::map::ConcreteType::U32:
        if (m_objectChoice.hasValue())
            result = ::zserio::calcHashCode(result, m_objectChoice.get<uint32_t>());
        break;
    case ::map::ConcreteType::STRING:
        if (m_objectChoice.hasValue())
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::std::string>());
        break;
    case ::map::ConcreteType::DOUBLE:
        if (m_objectChoice.hasValue())
            result = ::zserio::calcHashCode(result, m_objectChoice.get<double>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ConcreteValue!");
    }

    return result;
}

void ConcreteValue::read(::zserio::BitStreamReader& in)
{
    m_objectChoice = readObject(in);
}

void ConcreteValue::write(::zserio::BitStreamWriter& out, ::zserio::PreWriteAction)
{
    switch (getType())
    {
    case ::map::ConcreteType::U32:
        out.writeBits(m_objectChoice.get<uint32_t>(), UINT8_C(32));
        break;
    case ::map::ConcreteType::STRING:
        out.writeString(m_objectChoice.get<::std::string>());
        break;
    case ::map::ConcreteType::DOUBLE:
        out.writeFloat64(m_objectChoice.get<double>());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice ConcreteValue!");
    }
}

::zserio::AnyHolder ConcreteValue::readObject(::zserio::BitStreamReader& in)
{
    switch (getType())
    {
    case ::map::ConcreteType::U32:
        return ::zserio::AnyHolder(static_cast<uint32_t>(in.readBits(UINT8_C(32))));
    case ::map::ConcreteType::STRING:
        return ::zserio::AnyHolder(static_cast<::std::string>(in.readString()));
    case ::map::ConcreteType::DOUBLE:
        return ::zserio::AnyHolder(static_cast<double>(in.readFloat64()));
    default:
        throw ::zserio::CppRuntimeException("No match in choice ConcreteValue!");
    }
}

} // namespace map
