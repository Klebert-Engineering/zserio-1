/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#ifndef MAP_ELEMENT_H
#define MAP_ELEMENT_H

#include <type_traits>
#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/PreWriteAction.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/Types.h>

namespace map
{

template <typename ZSERIO_T_ARG_TYPE, typename ZSERIO_T_ARG_VALUE>
class Element
{
private:
    ZSERIO_T_ARG_VALUE readValue(::zserio::BitStreamReader& in)
    {
        return ZSERIO_T_ARG_VALUE(in, getType());
    }

public:
    Element() noexcept:
            m_isInitialized(false)
    {
    }

    template <typename ZSERIO_T_value,
            typename ::std::enable_if<!::std::is_same<typename ::std::decay<ZSERIO_T_value>::type, Element>::value,
                    int>::type = 0>
    explicit Element(
            ZSERIO_T_value&& value_) :
            m_isInitialized(false),
            m_value_(::std::forward<ZSERIO_T_value>(value_))
    {
    }

    explicit Element(::zserio::BitStreamReader& in,
            ZSERIO_T_ARG_TYPE& type_) :
            m_type_(&type_),
            m_isInitialized(true),
            m_value_(readValue(in))
    {
    }

    ~Element() = default;

    Element(const Element& other) :
            m_value_(other.m_value_)
    {
        if (other.m_isInitialized)
            initialize(*other.m_type_);
        else
            m_isInitialized = false;
    }
    Element& operator=(const Element& other)
    {
        m_value_ = other.m_value_;
        if (other.m_isInitialized)
            initialize(*other.m_type_);
        else
            m_isInitialized = false;

        return *this;
    }

    Element(Element&& other) :
            m_value_(::std::move(other.m_value_))
    {
        if (other.m_isInitialized)
            initialize(*other.m_type_);
        else
            m_isInitialized = false;
    }
    Element& operator=(Element&& other)
    {
        m_value_ = ::std::move(other.m_value_);
        if (other.m_isInitialized)
            initialize(*other.m_type_);
        else
            m_isInitialized = false;

        return *this;
    }

    void initialize(
            ZSERIO_T_ARG_TYPE& type_)
    {
        m_type_ = &type_;
        m_isInitialized = true;

        initializeChildren();
    }
    bool isInitialized() const
    {
        return m_isInitialized;
    }
    void initializeChildren()
    {
        m_value_.initialize(getType());
    }

    const ZSERIO_T_ARG_TYPE& getType() const
    {
        if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter type of compound Element "
                "is not initialized!");

        return *m_type_;
    }

    ZSERIO_T_ARG_TYPE& getType()
    {
        if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter type of compound Element "
                "is not initialized!");

        return *m_type_;
    }

    ZSERIO_T_ARG_VALUE& getValue()
    {
        return m_value_;
    }
    const ZSERIO_T_ARG_VALUE& getValue() const
    {
        return m_value_;
    }
    void setValue(const ZSERIO_T_ARG_VALUE& value_)
    {
        m_value_ = value_;
    }
    void setValue(ZSERIO_T_ARG_VALUE&& value_)
    {
        m_value_ = std::move(value_);
    }

    size_t bitSizeOf(size_t bitPosition = 0) const
    {
        size_t endBitPosition = bitPosition;

        endBitPosition += m_value_.bitSizeOf(endBitPosition);

        return endBitPosition - bitPosition;
    }
    size_t initializeOffsets(size_t bitPosition)
    {
        size_t endBitPosition = bitPosition;

        endBitPosition = m_value_.initializeOffsets(endBitPosition);

        return endBitPosition;
    }

    bool operator==(const Element& other) const
    {
        if (this != &other)
        {
            return
                    (getType() == other.getType()) &&
                    (m_value_ == other.m_value_);
        }

        return true;
    }
    int hashCode() const
    {
        int result = ::zserio::HASH_SEED;

        result = ::zserio::calcHashCode(result, getType());
        result = ::zserio::calcHashCode(result, m_value_);

        return result;
    }

    void read(::zserio::BitStreamReader& in)
    {
        m_value_ = readValue(in);
    }
    void write(::zserio::BitStreamWriter& out,
            ::zserio::PreWriteAction preWriteAction = ::zserio::ALL_PRE_WRITE_ACTIONS)
    {
        if ((preWriteAction & ::zserio::PRE_WRITE_INITIALIZE_CHILDREN) != 0)
            initializeChildren();

        m_value_.write(out, ::zserio::NO_PRE_WRITE_ACTION);
    }

private:
    ZSERIO_T_ARG_TYPE* m_type_;
    bool m_isInitialized;
    ZSERIO_T_ARG_VALUE m_value_;
};

} // namespace map

#endif // MAP_ELEMENT_H
