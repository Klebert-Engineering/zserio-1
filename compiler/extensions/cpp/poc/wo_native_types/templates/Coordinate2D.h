/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#ifndef TEMPLATES_COORDINATE2_D_H
#define TEMPLATES_COORDINATE2_D_H

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/PreWriteAction.h>
#include <zserio/Types.h>
#include <zserio/HashCodeUtil.h>

namespace templates
{

template <class ZSERIO_T_ARG_TYPE>
class Coordinate2D
{
public:
    typedef Coordinate2D<ZSERIO_T_ARG_TYPE> type;

    Coordinate2D() noexcept :
        m_isInitialized(false),
        m_x_(),
        m_y_()
    {}

    template <typename ZSERIO_T_x,
            typename ZSERIO_T_y>
    explicit Coordinate2D(
            ZSERIO_T_x&& x_,
            ZSERIO_T_y&& y_) :
            m_isInitialized(false),
            m_x_(std::forward<ZSERIO_T_x>(x_)),
            m_y_(std::forward<ZSERIO_T_x>(y_))
    {
    }

    explicit Coordinate2D(::zserio::BitStreamReader& in,
            const ZSERIO_T_ARG_TYPE& xOffset_,
            const ZSERIO_T_ARG_TYPE& yOffset_) :
            m_xOffset_(&xOffset_),
            m_yOffset_(&yOffset_),
            m_isInitialized(true),
            m_x_(readX(in)),
            m_y_(readY(in))
    {}

    ~Coordinate2D() = default;

    Coordinate2D(const Coordinate2D& other) :
            m_x_(other.m_x_),
            m_y_(other.m_y_)
    {
        if (other.m_isInitialized)
            initialize(other.m_xOffset_, other.m_yOffset_);
        else
            m_isInitialized = false;
    }

    Coordinate2D& operator=(const Coordinate2D& other)
    {
        m_x_ = other.m_x_;
        m_y_ = other.m_y_;
        if (other.m_isInitialized)
            initialize(*other.m_xOffset_, *other.m_yOffset_);
        else
            m_isInitialized = false;

        return *this;
    }

    Coordinate2D(Coordinate2D&& other) :
            m_x_(::std::move(other.m_x_)),
            m_y_(::std::move(other.m_y_))
    {
        if (other.m_isInitialized)
            initialize(*other.m_xOffset_, *other.m_yOffset_);
        else
            m_isInitialized = false;
    }

    Coordinate2D& operator=(Coordinate2D&& other)
    {
        m_x_ = ::std::move(other.m_x_);
        m_y_ = ::std::move(other.m_y_);
        if (other.m_isInitialized)
            initialize(*other.m_xOffset_, *other.m_yOffset_);
        else
            m_isInitialized = false;

        return *this;
    }

    void initialize(
            const ZSERIO_T_ARG_TYPE& xOffset_,
            const ZSERIO_T_ARG_TYPE& yOffset_)
    {
        m_xOffset_ = &xOffset_;
        m_yOffset_ = &yOffset_;
        m_isInitialized = true;
    }

    bool isInitialized() const
    {
        return m_isInitialized;
    }

    const ZSERIO_T_ARG_TYPE& getXOffset() const
    {
        if (!m_isInitialized)
            throw ::zserio::CppRuntimeException("Parameter xOffset of compound Coordinate2D "
                    "is not initialized!");

        return *m_xOffset_;
    }

    const ZSERIO_T_ARG_TYPE& getYOffset() const
    {
        if (!m_isInitialized)
            throw ::zserio::CppRuntimeException("Parameter yOffset of compound Coordinate2D "
                    "is not initialized!");

        return *m_yOffset_;
    }

    ZSERIO_T_ARG_TYPE& getX()
    {
        return m_x_;
    }

    const ZSERIO_T_ARG_TYPE& getX() const
    {
        return m_x_;
    }

    void setX(const ZSERIO_T_ARG_TYPE& x_)
    {
        m_x_ = x_;
    }

    void setX(ZSERIO_T_ARG_TYPE&& x_)
    {
        m_x_ = std::move(x_);
    }

    ZSERIO_T_ARG_TYPE& getY()
    {
        return m_y_;
    }

    const ZSERIO_T_ARG_TYPE& getY() const
    {
        return m_y_;
    }

    void setY(const ZSERIO_T_ARG_TYPE& y_)
    {
        m_y_ = y_;
    }

    void setY(ZSERIO_T_ARG_TYPE&& y_)
    {
        m_y_ = std::move(y_);
    }

    ZSERIO_T_ARG_TYPE funcGetX() const
    {
        return static_cast<ZSERIO_T_ARG_TYPE>(getX() + getXOffset());
    }

    ZSERIO_T_ARG_TYPE funcGetY() const
    {
        return static_cast<ZSERIO_T_ARG_TYPE>(getY() + getYOffset());
    }

    size_t bitSizeOf(size_t bitPosition = 0) const
    {
        size_t endBitPosition = bitPosition;

        endBitPosition += m_x_.bitSizeOf(endBitPosition);
        endBitPosition += m_y_.bitSizeOf(endBitPosition);

        return endBitPosition - bitPosition;
    }

    size_t initializeOffsets(size_t bitPosition)
    {
        size_t endBitPosition = bitPosition;

        endBitPosition += m_x_.initializeOffsets(endBitPosition);
        endBitPosition += m_x_.initializeOffsets(endBitPosition);

        return endBitPosition;
    }

    bool operator==(const Coordinate2D& other) const
    {
        if (this != &other)
        {
            return
                    (getXOffset() == other.getXOffset()) &&
                    (getYOffset() == other.getYOffset()) &&
                    (m_x_ == other.m_x_) &&
                    (m_y_ == other.m_y_);
        }

        return true;
    }

    int hashCode() const
    {
        int result = ::zserio::HASH_SEED;

        result = ::zserio::calcHashCode(result, getXOffset());
        result = ::zserio::calcHashCode(result, getYOffset());
        result = ::zserio::calcHashCode(result, m_x_);
        result = ::zserio::calcHashCode(result, m_y_);

        return result;
    }

    void read(::zserio::BitStreamReader& in)
    {
        m_x_ = readX(in);
        m_y_ = readY(in);
    }

    void write(::zserio::BitStreamWriter& out,
            ::zserio::PreWriteAction preWriteAction = ::zserio::ALL_PRE_WRITE_ACTIONS)
    {
        m_x_.write(out);
        m_y_.write(out);
    }

private:
    ZSERIO_T_ARG_TYPE readX(::zserio::BitStreamReader& in)
    {
        return ZSERIO_T_ARG_TYPE(in);
    }

    ZSERIO_T_ARG_TYPE readY(::zserio::BitStreamReader& in)
    {
        return ZSERIO_T_ARG_TYPE(in);
    }

    ZSERIO_T_ARG_TYPE* m_xOffset_;
    ZSERIO_T_ARG_TYPE* m_yOffset_;
    bool m_isInitialized;
    ZSERIO_T_ARG_TYPE m_x_;
    ZSERIO_T_ARG_TYPE m_y_;
};

} // namespace templates

#endif // TEMPLATES_COORDINATE2_D_H
