/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#ifndef ARRAY_ARRAY_H
#define ARRAY_ARRAY_H

#include <vector>
#include <type_traits>

#include <zserio/Arrays.h>
#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/PreWriteAction.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/Types.h>
#include <zserio/Templates.h>

namespace array
{

template <class ZSERIO_T_ARG_TYPE>
class Array
{
private:
    class ElementFactory_values
    {
         public:
            explicit ElementFactory_values(Array& owner) : m_owner(owner) {}

            void create(::std::vector<ZSERIO_T_ARG_TYPE>& array, ::zserio::BitStreamReader& in, size_t index) const
            {
                (void)index;
                array.emplace_back(in); // we already know number of arguments here!
            }

        private:
            Array& m_owner;
    };

    ::std::vector<ZSERIO_T_ARG_TYPE> readValues(::zserio::BitStreamReader& in)
    {
        ::std::vector<ZSERIO_T_ARG_TYPE> readField;
        ::zserio::readAuto(::zserio::ObjectArrayTraits<ZSERIO_T_ARG_TYPE, ElementFactory_values>(ElementFactory_values(*this)), readField, in);
        return readField;
    }

public:
    Array() noexcept
    {}

    template <typename ZSERIO_T_values,
            typename ::std::enable_if<!::std::is_same<typename ::std::decay<ZSERIO_T_values>::type, Array>::values,
                    int>::type = 0>
    explicit Array(
            ZSERIO_T_values&& values_) :
            m_values_(::std::forward<ZSERIO_T_values>(values_))
    {
    }

    explicit Array(::zserio::BitStreamReader& in) :
            m_values_(readValues(in))
    {
    }

    ~Array() = default;

    Array(const Array&) = default;
    Array& operator=(const Array&) = default;

    Array(Array&&) = default;
    Array& operator=(Array&&) = default;

    ::std::vector<ZSERIO_T_ARG_TYPE>& getValues()
    {
        return m_values_;
    }

    const ::std::vector<ZSERIO_T_ARG_TYPE>& getValues() const
    {
        return m_values_;
    }

    void setValues(const ::std::vector<ZSERIO_T_ARG_TYPE>& values_)
    {
        m_values_ = values_;
    }

    void setValues(::std::vector<ZSERIO_T_ARG_TYPE>&& values_)
    {
        m_values_ = std::move(values_);
    }

    size_t bitSizeOf(size_t bitPosition = 0) const
    {
        size_t endBitPosition = bitPosition;

        endBitPosition += ::zserio::bitSizeOfAuto(::zserio::ObjectArrayTraits<ZSERIO_T_ARG_TYPE>(), m_values_, endBitPosition);

        return endBitPosition - bitPosition;
    }

    size_t initializeOffsets(size_t bitPosition)
    {
        size_t endBitPosition = bitPosition;

        endBitPosition = ::zserio::initializeOffsetsAuto(::zserio::ObjectArrayTraits<ZSERIO_T_ARG_TYPE>(), m_values_, endBitPosition);

        return endBitPosition;
    }

    bool operator==(const Array& other) const
    {
        if (this != &other)
        {
            return
                    (m_values_ == other.m_values_);
        }

        return true;
    }

    int hashCode() const
    {
        int result = ::zserio::HASH_SEED;

        result = ::zserio::calcHashCode(result, m_values_);

        return result;
    }

    void read(::zserio::BitStreamReader& in)
    {
        m_values_ = readValues(in);
    }

    void write(::zserio::BitStreamWriter& out,
            ::zserio::PreWriteAction preWriteAction = ::zserio::ALL_PRE_WRITE_ACTIONS)
    {
        ::zserio::writeAuto(::zserio::ObjectArrayTraits<ZSERIO_T_ARG_TYPE>(), m_values_, out);
    }

private:
    ::std::vector<ZSERIO_T_ARG_TYPE> m_values_;
};

} // namespace array

#endif // ARRAY_ARRAY_H
